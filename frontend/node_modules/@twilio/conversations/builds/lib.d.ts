import { SyncClient, SyncDocument, SyncList } from "twilio-sync";
import { LogLevelDesc } from "loglevel";
import { Transport, TwilsockClient, InitRegistration, TransportResult } from "twilsock";
import { ConnectionState as TwilsockConnectionState } from "twilsock";
import { ReplayEventEmitter } from "@twilio/replay-event-emitter";
import { ChannelType, Notifications } from "@twilio/notifications";
import { Notifications as NotificationClient } from "@twilio/notifications";
import { McsClient, MediaCategory, McsMedia } from "@twilio/mcs-client";
import { MediaCategory as McsMediaCategory } from "@twilio/mcs-client";
interface ConfigurationResponse {
    options: {
        consumption_report_interval: string;
        user_infos_to_subscribe: number;
        reachability_enabled: boolean;
        http_cache_interval: string;
        my_conversations_page_size: number;
        media_attachments_count_limit: number;
        media_attachment_size_limit_in_mb: number;
        media_attachments_total_size_limit_in_mb: number;
        email_histories_allowed_mime_types: string[];
        email_bodies_allowed_mime_types: string[];
    };
    sync_objects: {
        my_conversations: string;
        my_user_info: string;
    };
    links: {
        my_conversations: string;
        conversations: string;
        users: string;
        current_user: string;
        typing: string;
        media_service: string;
        media_set_service: string;
        messages_receipts: string;
    };
    identity: string;
    url: string;
}
// twilio-conversations is used by Flex SDK. Please DO NOT change
declare class Logger {
    private prefix;
    private constructor();
    static scope(prefix: string): Logger;
    setLevel(level: LogLevelDesc): void;
    static setLevel(level: LogLevelDesc): void;
    trace(...args: any[]): void;
    debug(...args: any[]): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
    static trace(...args: any[]): void;
    static debug(...args: any[]): void;
    static info(...args: any[]): void;
    static warn(...args: any[]): void;
    static error(...args: any[]): void;
}
/**
 * Represents conversation limits.
 */
interface ConversationLimits {
    /**
     * Maximum amount of attachments.
     */
    mediaAttachmentsCountLimit: number;
    /**
     * Maximum attachment size in MB.
     */
    mediaAttachmentSizeLimitInMb: number;
    /**
     * Maximum total attachment size in MB.
     */
    mediaAttachmentsTotalSizeLimitInMb: number;
    /**
     * Allowed mime types for E-Mail histories.
     */
    emailHistoriesAllowedMimeTypes: string[];
    /**
     * Allowed mime types for E-Mail bodies.
     */
    emailBodiesAllowedMimeTypes: string[];
}
interface BackoffConfiguration {
    min: number;
    max: number;
    maxAttemptsCount: number;
}
declare class Configuration {
    readonly links: {
        myConversations: string;
        conversations: string;
        users: string;
        currentUser: string;
        typing: string;
        mediaService: string;
        mediaSetService: string;
        messagesReceipts: string;
    };
    readonly limits: ConversationLimits;
    readonly productId?: string;
    readonly typingIndicatorTimeoutOverride?: number;
    readonly typingIndicatorTimeoutDefault: number;
    readonly backoffConfiguration: BackoffConfiguration;
    readonly retryWhenThrottled: boolean;
    readonly consumptionReportInterval: number;
    readonly userInfosToSubscribe: number;
    readonly httpCacheInterval: number;
    readonly reachabilityEnabled: boolean;
    readonly userIdentity: string;
    readonly userInfo: string;
    readonly myConversations: string;
    constructor(options: ClientOptions, configurationResponse: ConfigurationResponse, logger: Logger);
}
interface CommandExecutorServices {
    transport: Transport;
}
declare class CommandExecutor {
    private _serviceUrl;
    private _services;
    private _productId?;
    constructor(_serviceUrl: string, _services: CommandExecutorServices, _productId?: string);
    private _preProcessUrl;
    private _makeRequest;
    fetchResource<REQ = void, RESP = void>(url: string, requestBody?: REQ): Promise<RESP>;
    mutateResource<REQ = void, RESP = void>(method: "post" | "delete", url: string, requestBody?: REQ): Promise<RESP>;
}
/**
 * Represents a JSON value.
 */
type JSONValue = null | string | number | boolean | JSONObject | JSONArray;
/**
 * Represents a JSON object.
 */
type JSONObject = {
    [x: string]: JSONValue;
};
/**
 * Represents a JSON array.
 */
type JSONArray = JSONValue[];
type UserEvents = {
    updated: (data: {
        user: User;
        updateReasons: UserUpdateReason[];
    }) => void;
    userSubscribed: (user: User) => void;
    userUnsubscribed: (user: User) => void;
};
interface UserServices {
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
/**
 * The reason for the `updated` event being emitted by a user.
 */
type UserUpdateReason = "friendlyName" | "attributes" | "reachabilityOnline" | "reachabilityNotifiable";
interface UserUpdatedEventArgs {
    user: User;
    updateReasons: UserUpdateReason[];
}
/**
 * Extended user information.
 * Note that `isOnline` and `isNotifiable` properties are eligible
 * for use only if the reachability function is enabled.
 * You may check if it is enabled by reading the value of {@link Client.reachabilityEnabled}.
 */
declare class User extends ReplayEventEmitter<UserEvents> {
    private links;
    private configuration;
    private readonly services;
    private entity;
    private state;
    private promiseToFetch;
    private subscribed;
    private _initializationPromise;
    private _resolveInitializationPromise;
    /**
     * @internal
     */
    constructor(identity: string, entityName: string, configuration: Configuration | null, services: UserServices);
    /**
     * Fired when the properties or the reachability status of the message has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link User} `user` - the user in question
     *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    readonly updated = "updated";
    /**
     * Fired when the client has subscribed to the user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    readonly userSubscribed = "userSubscribed";
    /**
     * Fired when the client has unsubscribed from the user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    readonly userUnsubscribed = "userUnsubscribed";
    /**
     * User identity.
     */
    get identity(): string;
    set identity(identity: string);
    set entityName(name: string);
    /**
     * Custom attributes of the user.
     */
    get attributes(): JSONValue;
    /**
     * Friendly name of the user, null if not set.
     */
    get friendlyName(): string | null;
    /**
     * Status of the real-time conversation connection of the user.
     */
    get isOnline(): boolean | null;
    /**
     * User push notification registration status.
     */
    get isNotifiable(): boolean | null;
    /**
     * True if this user is receiving real-time status updates.
     */
    get isSubscribed(): boolean;
    // Handles service updates
    _update(key: string, value: {
        value: string;
        notifiable: boolean | null;
        online: boolean | null;
    }): Promise<void>;
    // Fetch reachability info
    private _updateReachabilityInfo;
    // Fetch user
    _fetch(): Promise<User>;
    _ensureFetched(): Promise<User>;
    /**
     * Edit user attributes.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: JSONValue): Promise<User>;
    /**
     * Update the friendly name of the user.
     * @param friendlyName New friendly name.
     */
    updateFriendlyName(friendlyName: string): Promise<User>;
    /**
     * Remove the user from the subscription list.
     * @return A promise of completion.
     */
    unsubscribe(): Promise<void>;
    _resolveInitialization(configuration: Configuration, identity: string, entityName: string, emitUpdated: boolean): void;
}
declare class Network {
    private readonly configuration;
    private readonly services;
    private cacheLifetime;
    private readonly cache;
    private timer;
    constructor(configuration: any, services: any);
    private isExpired;
    private cleanupCache;
    pokeTimer(): void;
    private executeWithRetry;
    get<T>(url: string): Promise<TransportResult<T>>;
}
type UsersEvents = {
    userUpdated: (data: {
        user: User;
        updateReasons: UserUpdateReason[];
    }) => void;
    userSubscribed: (user: User) => void;
    userUnsubscribed: (user: User) => void;
};
interface UsersServices {
    network: Network;
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
/**
 * Container for known users
 */
declare class Users extends ReplayEventEmitter<UsersEvents> {
    private readonly configuration;
    private readonly services;
    private subscribedUsers;
    private fifoStack;
    readonly myself: User;
    constructor(myself: User, configuration: Configuration, services: UsersServices);
    private handleUnsubscribeUser;
    private handleSubscribeUser;
    /**
     * Gets user, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the FIFO stack
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity?: string, entityName?: string): Promise<User>;
    /**
     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}
     */
    getSubscribedUsers(): Promise<Array<User>>;
    /**
     * @returns {Promise<string>} User's sync unique name
     */
    private getSyncUniqueName;
}
type ParticipantEvents = {
    typingEnded: (participant: Participant) => void;
    typingStarted: (participant: Participant) => void;
    updated: (data: {
        participant: Participant;
        updateReasons: ParticipantUpdateReason[];
    }) => void;
};
interface ParticipantDescriptor {
    attributes?: JSONValue;
    dateCreated: Date | null;
    dateUpdated: Date | null;
    identity: string;
    roleSid?: string;
    lastConsumedMessageIndex: number | null;
    lastConsumptionTimestamp: number;
    type: ParticipantType;
    userInfo: string;
    bindings?: ParticipantBindings;
}
interface ParticipantServices {
    users: Users;
    commandExecutor: CommandExecutor;
}
interface ParticipantLinks {
    self: string;
}
/**
 * The reason for the `updated` event being emitted by a participant.
 */
type ParticipantUpdateReason = "attributes" | "dateCreated" | "dateUpdated" | "roleSid" | "lastReadMessageIndex" | "lastReadTimestamp" | "bindings";
/**
 * Type of a participant.
 */
type ParticipantType = "chat" | "sms" | "whatsapp" | "email";
interface ParticipantUpdatedEventArgs {
    participant: Participant;
    updateReasons: ParticipantUpdateReason[];
}
/**
 * Bindings for conversation participant.
 */
interface ParticipantBindings {
    email?: ParticipantEmailBinding;
}
/**
 * Email participation level.
 * to = to/from
 * cc = cc
 */
type ParticipantEmailLevel = "to" | "cc";
/**
 * Bindings for email participant.
 */
interface ParticipantEmailBinding {
    name: string;
    address: string;
    level: ParticipantEmailLevel;
}
/**
 * A participant represents a remote client in a conversation.
 */
declare class Participant extends ReplayEventEmitter<ParticipantEvents> {
    private state;
    private readonly links;
    private readonly services;
    /**
     * Conversation that the remote client is a participant of.
     */
    readonly conversation: Conversation;
    /**
     * The server-assigned unique identifier for the participant.
     */
    get sid(): string;
    /**
     * Custom attributes of the participant.
     */
    get attributes(): JSONValue;
    /**
     * Date this participant was created on.
     */
    get dateCreated(): Date | null;
    /**
     * Date this participant was last updated on.
     */
    get dateUpdated(): Date | null;
    /**
     * Identity of the participant.
     */
    get identity(): string | null;
    /**
     * Indicates whether the participant is currently typing.
     */
    get isTyping(): boolean;
    /**
     * The index of the last read message by the participant.
     * Note that retrieving messages on a client endpoint does not mean that messages are read,
     * please consider reading about the [Read Horizon feature](https://www.twilio.com/docs/api/chat/guides/consumption-horizon)
     * to find out about the proper way to mark messages as read.
     */
    get lastReadMessageIndex(): number | null;
    /**
     * Date of the most recent read horizon update.
     */
    get lastReadTimestamp(): Date | null;
    get roleSid(): string;
    /**
     * Type of the participant.
     */
    get type(): ParticipantType;
    /**
     * Get the bindings mapping for the current participant.
     * Available binding depends on the participant type.
     * You could access it as `participant.bindings.sms?.address` or
     * using the type dynamically `participant.bindings[participant.type]`
     * just be aware that the binding information has different structure for
     * each participant type.
     * See also {ParticipantEmailBinding}, the only available currently binding descriptor.
     */
    get bindings(): ParticipantBindings;
    /**
     * @internal
     */
    constructor(data: ParticipantDescriptor, sid: string, conversation: Conversation, links: ParticipantLinks, services: ParticipantServices);
    /**
     * Fired when the participant has started typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly typingStarted = "typingStarted";
    /**
     * Fired when the participant has stopped typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly typingEnded = "typingEnded";
    /**
     * Fired when the fields of the participant have been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Participant} participant - the participant in question
     *     * {@link ParticipantUpdateReason}[] updateReasons - array of reasons for the update
     * @event
     */
    static readonly updated = "updated";
    /**
     * Internal method used to start or reset the typing indicator timeout (with event emitting).
     * @internal
     */
    _startTyping(timeout: any): this;
    /**
     * Internal method function used to stop the typing indicator timeout (with event emitting).
     * @internal
     */
    _endTyping(): void;
    /**
     * Internal method function used update local object's property roleSid with a new value.
     * @internal
     */
    _update(data: any): this;
    /**
     * Get the user for this participant and subscribes to it. Supported only for participants of type `chat`.
     */
    getUser(): Promise<User>;
    /**
     * Remove the participant from the conversation.
     */
    remove(): Promise<void>;
    /**
     * Update the attributes of the participant.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: JSONValue): Promise<Participant>;
}
interface ParticipantResponse {
    account_sid: string;
    chat_service_sid: string;
    conversation_sid: string;
    role_sid: string;
    sid: string;
    attributes: string;
    date_created: string;
    date_updated: string;
    identity: string | null;
    messaging_binding: {
        type: string;
        address: string;
        proxy_address: string;
    } | null;
    url: string;
    links: {
        conversation: string;
    };
}
interface ParticipantBindingOptions {
    email?: ParticipantEmailBinding;
}
/**
 * Category of media. Possible values are as follows:
 * * `'media'`
 * * `'body'`
 * * `'history'`
 */
type MediaCategory$0 = McsMediaCategory;
interface MediaState {
    sid: string;
    category: MediaCategory$0;
    filename: string | null;
    contentType: string;
    size: number;
}
interface MediaServices {
    mcsClient: McsClient;
}
/**
 * Represents a media information for a message in a conversation.
 */
declare class Media {
    private state;
    private services;
    private mcsMedia;
    /**
     * @internal
     */
    constructor(data: MediaState | McsMedia, services: MediaServices);
    /**
     * Server-assigned unique identifier for the media.
     */
    get sid(): string;
    /**
     * File name. Null if absent.
     */
    get filename(): string | null;
    /**
     * Content type of the media.
     */
    get contentType(): string;
    /**
     * Size of the media in bytes.
     */
    get size(): number;
    /**
     * Media category, can be one of the {@link MediaCategory} values.
     */
    get category(): MediaCategory$0;
    /**
     * Returns the direct content URL for the media.
     *
     * This URL is impermanent, it will expire in several minutes and cannot be cached.
     * If the URL becomes expired, you need to request a new one.
     * Each call to this function produces a new temporary URL.
     */
    getContentTemporaryUrl(): Promise<string | null>;
    /**
     * Returns cached direct content URL for the media.
     *
     * This URL will expire in several minutes. This function does not refresh the URL and can be used to query it several times
     * without causing network traffic.
     * If the URL becomes expired, you need to request a new one using getContentTemporaryUrl().
     *
     * @returns {Promise<String>}
     */
    getCachedTemporaryUrl(): Promise<string | null>;
    private _fetchMcsMedia;
}
/**
 * Signifies the amount of participants which have the status for the message.
 */
type DeliveryAmount = "none" | "some" | "all";
interface AggregatedDeliveryDescriptor {
    total: number;
    delivered: DeliveryAmount;
    failed: DeliveryAmount;
    read: DeliveryAmount;
    sent: DeliveryAmount;
    undelivered: DeliveryAmount;
}
/**
 * Contains aggregated information about delivery statuses of a message across all participants
 * of a conversation.
 *
 * At any moment during the message delivery to a participant, the message can have zero or more of following
 * delivery statuses:
 * * Message is considered as **sent** to a participant if the nearest upstream carrier accepted the message.
 * * Message is considered as **delivered** to a participant if Twilio has received confirmation of message
 * delivery from the upstream carrier, and, where available, the destination handset.
 * * Message considered as **undelivered** to a participant if Twilio has received a delivery receipt
 * indicating that the message was not delivered. This can happen for many reasons including carrier content
 * filtering and the availability of the destination handset.
 * * Message considered as **read** by a participant if the message has been delivered and opened by the
 * recipient in a conversation. The recipient must have enabled the read receipts.
 * * Message considered as **failed** to be delivered to a participant if the message could not be sent.
 * This can happen for various reasons including queue overflows, account suspensions and media
 * errors (in the case of MMS for instance).
 *
 * {@link AggregatedDeliveryReceipt} class contains an aggregated value {@link DeliveryAmount} for each delivery status.
 */
declare class AggregatedDeliveryReceipt {
    private state;
    /**
     * @internal
     */
    constructor(data: AggregatedDeliveryDescriptor);
    /**
     * Maximum number of delivery events expected for the message.
     */
    get total(): number;
    /**
     * Message is considered as **sent** to a participant if the nearest upstream carrier accepted the message.
     *
     * @return Amount of participants that have the **sent** delivery status for the message.
     */
    get sent(): DeliveryAmount;
    /**
     * Message is considered as **delivered** to a participant if Twilio has received confirmation of message
     * delivery from the upstream carrier, and, where available, the destination handset.
     *
     * @return Amount of participants that have the **delivered** delivery status for the message.
     */
    get delivered(): DeliveryAmount;
    /**
     * Message is considered as **read** by a participant, if the message has been delivered and opened by the
     * recipient in a conversation. The recipient must have enabled the read receipts.
     *
     * @return Amount of participants that have the **read** delivery status for the message.
     */
    get read(): DeliveryAmount;
    /**
     * Message is considered as **undelivered** to a participant if Twilio has received a delivery receipt
     * indicating that the message was not delivered. This can happen for many reasons including carrier content
     * filtering and the availability of the destination handset.
     *
     * @return Ammount of participants that have the **undelivered** delivery status for the message.
     */
    get undelivered(): DeliveryAmount;
    /**
     * Message is considered as **failed** to be delivered to a participant if the message could not be sent.
     * This can happen for various reasons including queue overflows, account suspensions and media
     * errors (in the case of MMS for instance). Twilio does not charge you for failed messages.
     *
     * @return Amount of participants that have the **failed** delivery status for the message.
     */
    get failed(): DeliveryAmount;
    _update(data: AggregatedDeliveryDescriptor): void;
    _isEquals(data: AggregatedDeliveryDescriptor): boolean;
}
/**
 * Message delivery status.
 */
type DeliveryStatus = "sent" | "delivered" | "failed" | "read" | "undelivered" | "queued";
interface DetailedDeliveryReceiptDescriptor {
    sid: string;
    message_sid: string;
    conversation_sid: string;
    channel_message_sid: string;
    participant_sid: string;
    status: DeliveryStatus;
    error_code: string | null;
    date_created: string;
    date_updated: string;
}
/**
 * Represents a delivery receipt of a message.
 */
declare class DetailedDeliveryReceipt {
    /**
     * Unique identifier for the delivery receipt.
     */
    sid: string;
    /**
     * Unique identifier for the message in the conversation.
     */
    messageSid: string;
    /**
     * Unique identifier for the conversation.
     */
    conversationSid: string;
    /**
     * Unique identifier for the `‘channel’` message (e.g., `WAxx` for WhatsApp, `SMxx` for SMS).
     */
    channelMessageSid: string;
    /**
     * Unique identifier for the participant.
     */
    participantSid: string;
    /**
     * Status of the message delivery.
     */
    status: DeliveryStatus;
    /**
     * Numeric error code mapped from Status callback code. Information about the error codes can be found
     * [here](https://www.twilio.com/docs/sms/api/message-resource#delivery-related-errors).
     */
    errorCode: string | 0;
    /**
     * Date this delivery receipt was created on.
     */
    dateCreated: string;
    /**
     * Date this delivery receipt was last updated on.
     */
    dateUpdated: string;
    /**
     * @internal
     */
    constructor(descriptor: DetailedDeliveryReceiptDescriptor);
}
type MessageEvents = {
    updated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
};
interface MessageServices {
    mcsClient: McsClient;
    network: Network;
    commandExecutor: CommandExecutor;
}
interface MessageLinks {
    self: string;
    conversation: string;
    messages_receipts: string;
}
/**
 * The reason for the `updated` event being emitted by a message.
 */
type MessageUpdateReason = "body" | "lastUpdatedBy" | "dateCreated" | "dateUpdated" | "attributes" | "author" | "deliveryReceipt" | "subject";
/**
 * Type of a message.
 */
type MessageType = "text" | "media";
interface MessageUpdatedEventArgs {
    message: Message;
    updateReasons: MessageUpdateReason[];
}
interface MessageData {
    sid: string;
    text?: string;
    type?: MessageType;
    author: string | null;
    subject: string | null;
    lastUpdatedBy?: string | null;
    attributes?: JSONValue;
    dateUpdated: string;
    timestamp?: string;
    medias?: Media[];
    media?: Media;
    memberSid?: string;
    delivery?: AggregatedDeliveryDescriptor;
}
/**
 * A message in a conversation.
 */
declare class Message extends ReplayEventEmitter<MessageEvents> {
    /**
     * Conversation that the message is in.
     */
    readonly conversation: Conversation;
    private readonly links;
    private readonly configuration;
    private readonly services;
    private state;
    /**
     * @internal
     */
    constructor(index: number, data: MessageData, conversation: Conversation, links: MessageLinks, configuration: Configuration, services: MessageServices);
    /**
     * Fired when the properties or the body of the message has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Message} message - the message in question
     *     * {@link MessageUpdateReason}[] updateReasons - array of reasons for the update
     */
    static readonly updated = "updated";
    /**
     * The server-assigned unique identifier for the message.
     */
    get sid(): string;
    /**
     * Name of the user that sent the message.
     */
    get author(): string | null;
    /**
     * Message subject. Used only in email conversations.
     */
    get subject(): string | null;
    /**
     * Body of the message.
     */
    get body(): string | null;
    /**
     * Date this message was last updated on.
     */
    get dateUpdated(): Date | null;
    /**
     * Index of the message in the conversation's messages list.
     * By design of the Conversations system, the message indices may have arbitrary gaps between them,
     * that does not necessarily mean they were deleted or otherwise modified - just that
     * messages may have some non-contiguous indices even if they are being sent immediately one after another.
     *
     * Trying to use indices for some calculations is going to be unreliable.
     *
     * To calculate the number of unread messages it is better to use the read horizon API.
     * See {@link Conversation.getUnreadMessagesCount} for details.
     */
    get index(): number;
    /**
     * Identity of the last user that updated the message.
     */
    get lastUpdatedBy(): string | null;
    /**
     * Date this message was created on.
     */
    get dateCreated(): Date | null;
    /**
     * Custom attributes of the message.
     */
    get attributes(): JSONValue;
    /**
     * Type of the message.
     */
    get type(): MessageType;
    /**
     * One of the attached media (if present).
     * @deprecated Use attachedMedia instead. Note that the latter is now an array.
     */
    get media(): Media | null;
    /**
     * Return all media attachments, except email body/history attachments, without temporary urls.
     */
    get attachedMedia(): Array<Media> | null;
    /**
     * The server-assigned unique identifier of the authoring participant.
     */
    get participantSid(): string | null;
    /**
     * Aggregated information about the message delivery statuses across all participants of a conversation..
     */
    get aggregatedDeliveryReceipt(): AggregatedDeliveryReceipt | null;
    /**
     * Return a (possibly empty) array of media matching a specific set of categories.
     * Allowed category is so far only 'media'.
     * @param categories Array of categories to match.
     * @returns Array of media descriptors matching given categories.
     */
    getMediaByCategory(categories: Array<MediaCategory>): Array<Media> | null;
    /**
     * Get a media descriptor for an email body attachment of a provided type.
     * Allowed body types are returned in the Conversation.limits().emailBodiesAllowedMimeTypes array.
     * @param type Type of email body to request, defaults to `text/plain`.
     */
    getEmailBody(type?: string): Media | null;
    /**
     * Get a media descriptor for an email history attachment of a provided type.
     * Allowed body types are returned in the Conversation.limits().emailHistoriesAllowedMimeTypes array.
     * @param type Type of email history to request, defaults to `text/plain`.
     */
    getEmailHistory(type?: string): Media | null;
    _update(data: any): void;
    /**
     * Get the participant who is the author of the message.
     */
    getParticipant(): Promise<Participant>;
    /**
     * Get the delivery receipts of the message.
     */
    getDetailedDeliveryReceipts(): Promise<DetailedDeliveryReceipt[]>;
    /**
     * Remove the message.
     */
    remove(): Promise<Message>;
    /**
     * Edit the message body.
     * @param body New body of the message.
     */
    updateBody(body: string): Promise<Message>;
    /**
     * Edit the message attributes.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: JSONValue): Promise<Message>;
    /**
     * Get content URLs for all media attachments in the given set using single operation.
     * @param contentSet Set of media attachments to query for content URL.
     */
    attachTemporaryUrlsFor(contentSet: Media[] | null): Promise<Media[]>;
    private _getDetailedDeliveryReceiptsPaginator;
}
/**
 * Pagination helper interface.
 * @typeParam T The item type.
 */
interface Paginator<T> {
    /**
     * Indicates the existence of the next page.
     */
    hasNextPage: boolean;
    /**
     * Indicates the existence of the previous page.
     */
    hasPrevPage: boolean;
    /**
     * Array of elements of type T on the current page.
     */
    items: T[];
    /**
     * Request next page.
     * Does not modify the existing object.
     */
    nextPage(): Promise<Paginator<T>>;
    /**
     * Request previous page.
     * Does not modify the existing object.
     */
    prevPage(): Promise<Paginator<T>>;
}
interface TypingIndicatorServices {
    twilsockClient: TwilsockClient;
    notificationClient: Notifications;
}
/**
 * An important note in regards to typing timeout timers. There are two places that the SDK can get the "typing_timeout" attribute from. The first
 * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the
 * "typing_timeout" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a
 * notification of type "twilio.ipmsg.typing_indicator". In this case, the "typing_timeout" value will be +1 of that in the console. This
 * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,
 * the timeout returned from the notification should be used as the timeout for the "typingEnded" event, +1 is to account for latency.
 *
 * @private
 */
/**
 * @class TypingIndicator
 *
 * @constructor
 * @private
 */
declare class TypingIndicator {
    private readonly services;
    private readonly configuration;
    private sentUpdates;
    private getConversation;
    private serviceTypingTimeout;
    constructor(getConversation: any, config: Configuration, services: TypingIndicatorServices);
    get typingTimeout(): number;
    /**
     * Initialize TypingIndicator controller
     * Registers for needed message types and sets listeners
     * @private
     */
    initialize(): void;
    /**
     * Remote participants typing events handler
     */
    private _handleRemoteTyping;
    /**
     * Send typing event for the given conversation sid
     * @param {String} conversationSid
     */
    send(conversationSid: string): Promise<void>;
    private _send;
}
/**
 * An unsent message. Returned from {@link MessageBuilder.build}.
 */
declare class UnsentMessage {
    private messagesEntity;
    text?: string;
    attributes: JSONValue;
    mediaContent: [MediaCategory, FormData | SendMediaOptions][];
    emailOptions: SendEmailOptions;
    /**
     * @internal
     */
    constructor(messagesEntity: any);
    /**
     * Send the prepared message to the conversation.
     * @returns Index of the new message in the conversation.
     */
    send(): Promise<number | null>;
}
/**
 * Pagination helper class.
 */
declare class RestPaginator<T> implements Paginator<T> {
    private state;
    /**
     * Indicates the existence of the next page.
     */
    get hasNextPage(): boolean;
    /**
     * Indicates the existence of the previous page
     */
    get hasPrevPage(): boolean;
    /**
     * Array of elements on the current page.
     */
    get items(): T[];
    /**
     * @internal
     */
    constructor(items: any, source: any, prevToken: any, nextToken: any);
    /**
     * Request the next page. Does not modify the existing object.
     */
    nextPage(): Promise<RestPaginator<T>>;
    /**
     * Request the previous page. Does not modify the existing object.
     */
    prevPage(): Promise<RestPaginator<T>>;
}
/**
 * @classdesc Pagination helper class for Sync
 *
 * @property {Array} items Array of elements on current page
 * @property {boolean} hasNextPage
 * @property {boolean} hasPrevPage
 */
declare class SyncPaginator<T> implements Paginator<T> {
    private state;
    hasNextPage: boolean;
    hasPrevPage: boolean;
    get items(): T[];
    /**
     * @param {Array} items Array of element for current page
     * @param {Object} params
     */
    constructor(items: any, pageSize: any, anchor: any, direction: any, source: any);
    nextPage(): Promise<RestPaginator<T>>;
    prevPage(): Promise<SyncPaginator<T> | RestPaginator<T>>;
}
interface MessageResponse {
    account_sid: string;
    chat_service_sid: string;
    conversation_sid: string;
    sid: string;
    index: number;
    attributes: string;
    author: string;
    participant_sid: string;
    body: string;
    subject: string;
    date_created: string;
    date_updated: string;
    url: string;
    media: {
        sid: string;
        size: string;
        content_type: string;
        filename: string;
    }[] | null;
    links: {
        conversation: string;
        messages_receipts: string;
    };
}
type MessagesEvents = {
    messageAdded: (message: Message) => void;
    messageRemoved: (message: Message) => void;
    messageUpdated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
};
interface MessagesServices {
    mcsClient: McsClient;
    network: Network;
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
/**
 * Represents the collection of messages in a conversation
 */
declare class Messages extends ReplayEventEmitter<MessagesEvents> {
    readonly conversation: Conversation;
    private readonly configuration;
    private readonly services;
    private readonly messagesByIndex;
    private messagesListPromise;
    constructor(conversation: Conversation, configuration: Configuration, services: MessagesServices);
    /**
     * Subscribe to the Messages Event Stream
     * @param name - The name of Sync object for the Messages resource.
     */
    subscribe(name: string): Promise<SyncList>;
    unsubscribe(): Promise<void>;
    /**
     * Send Message to the conversation, message could include both text and multiple media attachments.
     * @param message Message to post
     * @returns Returns a promise which can fail
     */
    sendV2(message: UnsentMessage): Promise<MessageResponse>;
    /**
     * Send Message to the conversation
     * @param message Message to post
     * @param attributes Message attributes
     * @param emailOptions Options that modify E-mail integration behaviors.
     * @returns Returns promise which can fail
     */
    send(message: null | string | FormData | SendMediaOptions, attributes?: JSONValue, emailOptions?: SendEmailOptions): Promise<MessageResponse>;
    /**
     * Send Media Message to the conversation
     * @param mediaContent Media content to post
     * @param attributes Message attributes
     * @param emailOptions Email options
     * @returns Returns promise which can fail
     */
    sendMedia(mediaContent: FormData | SendMediaOptions, attributes?: JSONValue, emailOptions?: SendEmailOptions): Promise<MessageResponse>;
    /**
     * Returns messages from conversation using paginator interface
     * @param pageSize Number of messages to return in single chunk. By default it's 30.
     * @param anchor Most early message id which is already known, or 'end' by default
     * @param direction Pagination order 'backwards' or 'forward', 'forward' by default
     * @returns Last page of messages by default
     */
    getMessages(pageSize: number | undefined, anchor: number | "end" | undefined, direction?: "forward" | "backwards"): Promise<SyncPaginator<Message>>;
    private _wrapPaginator;
    private _upsertMessage;
    /**
     * Returns last messages from conversation
     * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.
     * @param {String} [anchor] Most early message id which is already known, or 'end' by default
     * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default
     * @returns {Promise<SyncPaginator<Message>>} last page of messages by default
     * @private
     */
    private _getMessages;
}
/**
 * Message builder. Allows the message to be built and sent via method chaining.
 *
 * Example:
 *
 * ```ts
 * await testConversation.prepareMessage()
 *   .setBody('Hello!')
 *   .setAttributes({foo: 'bar'})
 *   .addMedia(media1)
 *   .addMedia(media2)
 *   .build()
 *   .send();
 * ```
 */
declare class MessageBuilder {
    private readonly limits;
    private readonly message;
    private emailBodies;
    private emailHistories;
    /**
     * @internal
     */
    constructor(limits: ConversationLimits, messagesEntity: Messages);
    /**
     * Sets the message body.
     * @param text Contents of the body.
     */
    setBody(text: string): MessageBuilder;
    /**
     * Sets the message subject.
     * @param subject Contents of the subject.
     */
    setSubject(subject: string): MessageBuilder;
    /**
     * Sets the message attributes.
     * @param attributes Message attributes.
     */
    setAttributes(attributes: JSONValue): MessageBuilder;
    /**
     * Set email body with given MIME-type.
     * @param mimeType Format of the body to set (text/plain or text/html).
     * @param body Body payload in selected format.
     */
    setEmailBody(mimeType: string, body: FormData | SendMediaOptions): MessageBuilder;
    /**
     * Set email history with given MIME-type.
     * @param mimeType Format of the history to set (text/plain or text/html).
     * @param history History payload in selected format.
     */
    setEmailHistory(mimeType: string, history: FormData | SendMediaOptions): MessageBuilder;
    /**
     * Adds media to the message.
     * @param payload Media to add.
     */
    addMedia(payload: FormData | SendMediaOptions): MessageBuilder;
    /**
     * Builds the message, making it ready to be sent.
     */
    build(): UnsentMessage;
    private getPayloadContentType;
}
type ConversationEvents = {
    participantJoined: (participant: Participant) => void;
    participantLeft: (participant: Participant) => void;
    participantUpdated: (data: {
        participant: Participant;
        updateReasons: ParticipantUpdateReason[];
    }) => void;
    messageAdded: (message: Message) => void;
    messageRemoved: (message: Message) => void;
    messageUpdated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
    typingEnded: (participant: Participant) => void;
    typingStarted: (participant: Participant) => void;
    updated: (data: {
        conversation: Conversation;
        updateReasons: ConversationUpdateReason[];
    }) => void;
    removed: (conversation: Conversation) => void;
};
interface ConversationServices {
    users: Users;
    typingIndicator: TypingIndicator;
    network: Network;
    mcsClient: McsClient;
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
interface ConversationDescriptor {
    channel: string;
    entityName: string;
    uniqueName: string;
    attributes: JSONValue;
    createdBy?: string;
    friendlyName?: string;
    lastConsumedMessageIndex: number;
    dateCreated: Date | null;
    dateUpdated: Date | null;
    notificationLevel?: NotificationLevel;
    bindings?: ConversationBindings;
}
interface ConversationLinks {
    self: string;
    messages: string;
    participants: string;
}
/**
 * The reason for the `updated` event being emitted by a conversation.
 */
type ConversationUpdateReason = "attributes" | "createdBy" | "dateCreated" | "dateUpdated" | "friendlyName" | "lastReadMessageIndex" | "state" | "status" | "uniqueName" | "lastMessage" | "notificationLevel" | "bindings";
/**
 * The status of the conversation, relative to the client: whether
 * the conversation has been `joined` or the client is
 * `notParticipating` in the conversation.
 */
type ConversationStatus = "notParticipating" | "joined";
/**
 * The user's notification level for the conversation. Determines
 * whether the currently logged-in user will receive pushes for events
 * in this conversation. Can be either `muted` or `default`, where
 * `default` defers to the global service push configuration.
 */
type NotificationLevel = "default" | "muted";
/**
 * The state of the conversation.
 */
interface ConversationState {
    /**
     * The current state.
     */
    current: "active" | "inactive" | "closed";
    /**
     * Date at which the latest conversation state update happened.
     */
    dateUpdated: Date;
}
interface ConversationUpdatedEventArgs {
    conversation: Conversation;
    updateReasons: ConversationUpdateReason[];
}
/**
 * Binding for email conversation.
 */
interface ConversationBindings {
    email?: ConversationEmailBinding;
    sms?: ConversationSmsBinding;
}
/**
 * Binding for email conversation.
 */
interface ConversationEmailBinding {
    name?: string;
    projected_address: string;
}
interface ConversationSmsBinding {
    address?: string;
}
/**
 * Configuration for attaching a media file to a message.
 * These options can be passed to {@link Conversation.sendMessage} and
 * {@link MessageBuilder.addMedia}.
 */
interface SendMediaOptions {
    /**
     * Content type of media.
     */
    contentType: null | string;
    /**
     * Optional filename.
     */
    filename?: string;
    /**
     * Content to post.
     */
    media: null | string | Buffer | Blob;
}
/**
 * These options can be passed to {@link Conversation.sendMessage}.
 */
interface SendEmailOptions {
    /**
     *  Message subject. Ignored for media messages.
     */
    subject?: string;
}
/**
 * Information about the last message of a conversation.
 */
interface LastMessage {
    /**
     * Message's index.
     */
    index?: number;
    /**
     *  Message's creation date.
     */
    dateCreated?: Date;
}
/**
 * A conversation represents communication between multiple Conversations clients
 */
declare class Conversation extends ReplayEventEmitter<ConversationEvents> {
    /**
     * Unique system identifier of the conversation.
     */
    readonly sid: string;
    readonly links: ConversationLinks;
    private readonly configuration;
    private readonly services;
    private channelState;
    private statusSource;
    private entityPromise;
    private entityName;
    private entity;
    private messagesEntity;
    private participantsEntity;
    private readonly participants;
    /**
     * @internal
     */
    constructor(descriptor: ConversationDescriptor, sid: string, links: ConversationLinks, configuration: Configuration, services: ConversationServices);
    /**
     * Fired when a participant has joined the conversation.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - participant that joined the conversation
     * @event
     */
    static readonly participantJoined = "participantJoined";
    /**
     * Fired when a participant has left the conversation.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - participant that left the conversation
     * @event
     */
    static readonly participantLeft = "participantLeft";
    /**
     * Fired when data of a participant has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Participant} `participant` - participant that has received the update
     *     * {@link ParticipantUpdateReason}[] `updateReasons` - array of reasons for update
     * @event
     */
    static readonly participantUpdated = "participantUpdated";
    /**
     * Fired when a new message has been added to the conversation.
     *
     * Parameters:
     * 1. {@link Message} `message` - message that has been added
     * @event
     */
    static readonly messageAdded = "messageAdded";
    /**
     * Fired when message is removed from the conversation's message list.
     *
     * Parameters:
     * 1. {@link Message} `message` - message that has been removed
     * @event
     */
    static readonly messageRemoved = "messageRemoved";
    /**
     * Fired when data of a message has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Message} `message` - message that has received the update
     *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for update
     * @event
     */
    static readonly messageUpdated = "messageUpdated";
    /**
     * Fired when a participant has stopped typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant that has stopped typing
     * @event
     */
    static readonly typingEnded = "typingEnded";
    /**
     * Fired when a participant has started typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant that has started typing
     * @event
     */
    static readonly typingStarted = "typingStarted";
    /**
     * Fired when the data of the conversation has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Conversation} `conversation` - conversation that has received the update
     *     * {@link ConversationUpdateReason}[] `updateReasons` - array of reasons for update
     * @event
     */
    static readonly updated = "updated";
    /**
     * Fired when the conversation was destroyed or the currently-logged-in user has left private conversation.
     *
     * Parameters:
     * 1. {@link Conversation} `conversation` - conversation that has been removed
     * @event
     */
    static readonly removed = "removed";
    /**
     * Unique name of the conversation.
     */
    get uniqueName(): string | null;
    /**
     * Status of the conversation.
     */
    get status(): ConversationStatus;
    /**
     * Name of the conversation.
     */
    get friendlyName(): string | null;
    /**
     * Date this conversation was last updated on.
     */
    get dateUpdated(): Date | null;
    /**
     * Date this conversation was created on.
     */
    get dateCreated(): Date | null;
    /**
     * Identity of the user that created this conversation.
     */
    get createdBy(): string;
    /**
     * Custom attributes of the conversation.
     */
    get attributes(): JSONValue;
    /**
     * Index of the last message the user has read in this conversation.
     */
    get lastReadMessageIndex(): number | null;
    /**
     * Last message sent to this conversation.
     */
    get lastMessage(): LastMessage | undefined;
    /**
     * User notification level for this conversation.
     */
    get notificationLevel(): NotificationLevel;
    get bindings(): ConversationBindings;
    /**
     * Current conversation limits.
     */
    get limits(): ConversationLimits;
    /**
     * State of the conversation.
     */
    get state(): ConversationState | undefined;
    /**
     * Load and subscribe to this conversation and do not subscribe to its participants and messages.
     * This or _subscribeStreams will need to be called before any events on conversation will fire.
     * @internal
     */
    _subscribe(): Promise<void | SyncDocument>;
    /**
     * Load the attributes of this conversation and instantiate its participants and messages.
     * This or _subscribe will need to be called before any events on the conversation will fire.
     * This will need to be called before any events on participants or messages will fire
     * @internal
     */
    _subscribeStreams(): Promise<void>;
    /**
     * Stop listening for and firing events on this conversation.
     * @internal
     */
    _unsubscribe(): Promise<[
        void,
        void
    ]>;
    /**
     * Set conversation status.
     * @internal
     */
    _setStatus(status: ConversationStatus, source: ConversationsDataSource): void;
    /**
     * Get the source of the conversation update.
     * @internal
     */
    _statusSource(): ConversationsDataSource;
    private static preprocessUpdate;
    /**
     * Update the local conversation object with new values.
     * @internal
     */
    _update(update: any): void;
    /**
     * @internal
     */
    private _onMessageAdded;
    private _setLastReadMessageIndex;
    /**
     * Add a participant to the conversation by its identity.
     * @param identity Identity of the Client to add.
     * @param attributes Attributes to be attached to the participant.
     */
    add(identity: string, attributes?: JSONValue): Promise<ParticipantResponse>;
    /**
     * Add a non-chat participant to the conversation.
     * @param proxyAddress Proxy (Twilio) address of the participant.
     * @param address User address of the participant.
     * @param attributes Attributes to be attached to the participant.
     * @param bindingOptions Options for adding email participants - name and CC/To level.
     */
    addNonChatParticipant(proxyAddress: string, address: string, attributes?: JSONValue, bindingOptions?: ParticipantBindingOptions): Promise<ParticipantResponse>;
    /**
     * Advance the conversation's last read message index to the current read horizon.
     * Rejects if the user is not a participant of the conversation.
     * Last read message index is updated only if the new index value is higher than the previous.
     * @param index Message index to advance to.
     * @return Resulting unread messages count in the conversation.
     */
    advanceLastReadMessageIndex(index: number): Promise<number>;
    /**
     * Delete the conversation and unsubscribe from its events.
     */
    delete(): Promise<Conversation>;
    /**
     * Get the custom attributes of this Conversation.
     */
    getAttributes(): Promise<JSONValue>;
    /**
     * Returns messages from the conversation using the paginator interface.
     * @param pageSize Number of messages to return in a single chunk. Default is 30.
     * @param anchor Index of the newest message to fetch. Default is from the end.
     * @param direction Query direction. By default it queries backwards
     * from newer to older. The `"forward"` value will query in the opposite direction.
     * @return A page of messages.
     */
    getMessages(pageSize?: number, anchor?: number, direction?: "backwards" | "forward"): Promise<Paginator<Message>>;
    /**
     * Get a list of all the participants who are joined to this conversation.
     */
    getParticipants(): Promise<Participant[]>;
    /**
     * Get conversation participants count.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Conversations system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    getParticipantsCount(): Promise<number>;
    /**
     * Get a participant by its SID.
     * @param participantSid Participant SID.
     */
    getParticipantBySid(participantSid: string): Promise<Participant | null>;
    /**
     * Get a participant by its identity.
     * @param identity Participant identity.
     */
    getParticipantByIdentity(identity?: string | null): Promise<Participant | null>;
    /**
     * Get the total message count in the conversation.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Conversations system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    getMessagesCount(): Promise<number>;
    /**
     * Get unread messages count for the user if they are a participant of this conversation.
     * Rejects if the user is not a participant of the conversation.
     *
     * Use this method to obtain the number of unread messages together with
     * {@link Conversation.updateLastReadMessageIndex} instead of relying on the
     * message indices which may have gaps. See {@link Message.index} for details.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Conversations system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    getUnreadMessagesCount(): Promise<number | null>;
    /**
     * Join the conversation and subscribe to its events.
     */
    join(): Promise<Conversation>;
    /**
     * Leave the conversation.
     */
    leave(): Promise<Conversation>;
    /**
     * Remove a participant from the conversation. When a string is passed as the
     * argument, it will assume that the string is an identity or SID.
     * @param participant Identity, SID or the participant object to remove.
     */
    /* eslint-disable @typescript-eslint/ban-ts-comment */
    // @ts-ignore TODO: fix validateTypesAsync typing
    removeParticipant(participant: string | Participant): Promise<void>;
    /**
     * Send a message to the conversation.
     * @param message Message body for the text message,
     * `FormData` or {@link SendMediaOptions} for media content. Sending FormData is supported only with the browser engine.
     * @param messageAttributes Attributes for the message.
     * @param emailOptions Email options for the message.
     * @return Index of the new message.
     */
    sendMessage(message: null | string | FormData | SendMediaOptions, messageAttributes?: JSONValue, emailOptions?: SendEmailOptions): Promise<number>;
    /**
     * New interface to prepare for sending a message.
     * Use instead of `sendMessage`.
     * @return A MessageBuilder to help set all message sending options.
     */
    prepareMessage(): MessageBuilder;
    /**
     * Set last read message index of the conversation to the index of the last known message.
     * @return Resulting unread messages count in the conversation.
     */
    setAllMessagesRead(): Promise<number>;
    /**
     * Set all messages in the conversation unread.
     * @return Resulting unread messages count in the conversation.
     */
    setAllMessagesUnread(): Promise<number>;
    /**
     * Set user notification level for this conversation.
     * @param notificationLevel New user notification level.
     */
    setUserNotificationLevel(notificationLevel: NotificationLevel): Promise<void>;
    /**
     * Send a notification to the server indicating that this client is currently typing in this conversation.
     * Typing ended notification is sent after a while automatically, but by calling this method again you ensure that typing ended is not received.
     */
    typing(): Promise<void>;
    /**
     * Update the attributes of the conversation.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: JSONValue): Promise<Conversation>;
    /**
     * Update the friendly name of the conversation.
     * @param friendlyName New friendly name.
     */
    updateFriendlyName(friendlyName: string): Promise<Conversation>;
    /**
     * Set the last read message index to the current read horizon.
     * @param index Message index to set as last read.
     * If null is provided, then the behavior is identical to {@link Conversation.setAllMessagesUnread}.
     * @returns Resulting unread messages count in the conversation.
     */
    updateLastReadMessageIndex(index: number | null): Promise<number>;
    /**
     * Update the unique name of the conversation.
     * @param uniqueName New unique name for the conversation. Setting unique name to null removes it.
     */
    updateUniqueName(uniqueName: string | null): Promise<Conversation>;
}
type ConversationsDataSource = "sync" | "chat" | "rest";
/**
 * Push notification type.
 */
type PushNotificationType = "twilio.conversations.new_message" | "twilio.conversations.added_to_conversation" | "twilio.conversations.removed_from_conversation";
interface PushNotificationDescriptor {
    title: string | null;
    body: string | null;
    sound: string | null;
    badge: number | null;
    action: string | null;
    type: PushNotificationType;
    data: Record<string, unknown>;
}
/**
 * Additional data for a given push notification.
 */
interface PushNotificationData {
    /**
     * SID of the conversation.
     */
    conversationSid?: string;
    /**
     * Index of the message in the conversation.
     */
    messageIndex?: number;
    /**
     * SID of the message in the conversation.
     */
    messageSid?: string;
}
/**
 * Push notification for a Conversations client.
 */
declare class PushNotification {
    /**
     * Title of the notification.
     */
    readonly title: string | null;
    /**
     * Text of the notification.
     */
    readonly body: string | null;
    /**
     * Sound of the notification.
     */
    readonly sound: string | null;
    /**
     * Number of the badge.
     */
    readonly badge: number | null;
    /**
     * Notification action (`click_action` in FCM terms and `category` in APN terms).
     */
    readonly action: string | null;
    /**
     * Type of the notification.
     */
    readonly type: PushNotificationType;
    /**
     * Additional data of the conversation.
     */
    readonly data: PushNotificationData;
    /**
     * @internal
     */
    constructor(data: PushNotificationDescriptor);
}
type ClientEvents = {
    conversationAdded: (conversation: Conversation) => void;
    conversationJoined: (conversation: Conversation) => void;
    conversationLeft: (conversation: Conversation) => void;
    conversationRemoved: (conversation: Conversation) => void;
    conversationUpdated: (data: {
        conversation: Conversation;
        updateReasons: ConversationUpdateReason[];
    }) => void;
    participantJoined: (participant: Participant) => void;
    participantLeft: (participant: Participant) => void;
    participantUpdated: (data: {
        participant: Participant;
        updateReasons: ParticipantUpdateReason[];
    }) => void;
    messageAdded: (message: Message) => void;
    messageRemoved: (message: Message) => void;
    messageUpdated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
    tokenAboutToExpire: (ttl: number) => void;
    tokenExpired: () => void;
    typingEnded: (participant: Participant) => void;
    typingStarted: (participant: Participant) => void;
    pushNotification: (pushNotification: PushNotification) => void;
    userSubscribed: (user: User) => void;
    userUnsubscribed: (user: User) => void;
    userUpdated: (data: {
        user: User;
        updateReasons: UserUpdateReason[];
    }) => void;
    stateChanged: (state: State) => void;
    connectionStateChanged: (state: TwilsockConnectionState) => void;
    connectionError: (data: {
        terminal: boolean;
        message: string;
        httpStatusCode?: number;
        errorCode?: number;
    }) => void;
};
/**
 * Connection state of the client. Possible values are as follows:
 * * `'connecting'` - client is offline and connection attempt is in process
 * * `'connected'` - client is online and ready
 * * `'disconnecting'` - client is going offline as disconnection is in process
 * * `'disconnected'` - client is offline and no connection attempt is in process
 * * `'denied'` - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed
 */
type ConnectionState = TwilsockConnectionState;
/**
 * State of the client. Possible values are as follows:
 * * `'failed'` - the client failed to initialize
 * * `'initialized'` - the client successfully initialized
 */
type State = "failed" | "initialized";
/**
 * Notifications channel type. Possible values are as follows:
 * * `'fcm'`
 * * `'apn'`
 */
type NotificationsChannelType = ChannelType;
type LogLevel = "trace" | "debug" | "info" | "warn" | "error" | "silent";
/**
 * Conversations client options.
 */
interface ClientOptions {
    /**
     * The level of logging to enable.
     */
    logLevel?: LogLevel;
    region?: string;
    productId?: string;
    twilsockClient?: TwilsockClient;
    transport?: Transport;
    notificationsClient?: NotificationClient;
    syncClient?: SyncClient;
    typingIndicatorTimeoutOverride?: number;
    consumptionReportIntervalOverride?: string;
    httpCacheIntervalOverride?: string;
    userInfosToSubscribeOverride?: number;
    retryWhenThrottledOverride?: boolean;
    backoffConfigOverride?: Record<string, unknown>;
    Chat?: ClientOptions;
    IPMessaging?: ClientOptions;
    Sync?: Record<string, unknown>;
    Notification?: Record<string, unknown>;
    Twilsock?: Record<string, unknown>;
    clientMetadata?: Record<string, unknown>;
    initRegistrations?: InitRegistration[];
    disableDeepClone?: boolean;
    typingUri?: string;
    apiUri?: string;
}
/**
 * Options for {@link Client.createConversation}.
 */
interface CreateConversationOptions {
    /**
     * Any custom attributes to attach to the conversation.
     */
    attributes?: JSONValue;
    /**
     * A non-unique display name of the conversation.
     */
    friendlyName?: string;
    /**
     * A unique identifier of the conversation.
     */
    uniqueName?: string;
}
/**
 * A client is the starting point to the Twilio Conversations functionality.
 */
declare class Client extends ReplayEventEmitter<ClientEvents> {
    /**
     * Client connection state.
     */
    connectionState: ConnectionState;
    private conversationsPromise;
    private _ensureReady;
    private _resolveEnsureReady;
    private _rejectEnsureReady;
    private fpaToken;
    private configuration;
    private conversations;
    private readonly options;
    private services;
    private readonly _myself;
    /**
     * Current version of the Conversations client.
     */
    static readonly version: string;
    /**
     * Current version of the Conversations client.
     */
    readonly version: string;
    private static readonly supportedPushChannels;
    private static readonly supportedPushDataFields;
    /**
     * Returned Conversations instance is not yet fully initialized. Calling any operations will block until it is.
     * Use connection events to monitor when client becomes fully available (connectionStateChanged with state
     * 'connected') or not available (connectionStateChange with state 'denied', event tokenExpired, event connectionError).
     *
     * @param fpaToken Access token
     * @param options Options to customize the Client
     * @returns A not yet fully-initialized client.
     */
    constructor(fpaToken: string, options?: ClientOptions | null);
    static populateInitRegistrations(reg: InitRegistration): void;
    /**
     * Fired when a conversation becomes visible to the client. The event is also triggered when the client creates a new conversation.
     * Fired for all conversations client has joined.
     *
     * Parameters:
     * 1. {@link Conversation} `conversation` - the conversation in question
     * @event
     */
    static readonly conversationAdded = "conversationAdded";
    /**
     * Fired when the client joins a conversation.
     *
     * Parameters:
     * 1. {@link Conversation} `conversation` - the conversation in question
     * @event
     */
    static readonly conversationJoined = "conversationJoined";
    /**
     * Fired when the client leaves a conversation.
     *
     * Parameters:
     * 1. {@link Conversation} `conversation` - the conversation in question
     * @event
     */
    static readonly conversationLeft = "conversationLeft";
    /**
     * Fired when a conversation is no longer visible to the client.
     *
     * Parameters:
     * 1. {@link Conversation} `conversation` - the conversation in question
     * @event
     */
    static readonly conversationRemoved = "conversationRemoved";
    /**
     * Fired when the attributes or the metadata of a conversation have been updated.
     * During conversation's creation and initialization, this event might be fired multiple times
     * for same joined or created conversation as new data is arriving from different sources.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Conversation} `conversation` - the conversation in question
     *     * {@link ConversationUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    static readonly conversationUpdated = "conversationUpdated";
    /**
     * Fired when a participant has joined a conversation.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly participantJoined = "participantJoined";
    /**
     * Fired when a participant has left a conversation.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly participantLeft = "participantLeft";
    /**
     * Fired when a participant's fields have been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Participant} `participant` - the participant in question
     *     * {@link ParticipantUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    static readonly participantUpdated = "participantUpdated";
    /**
     * Fired when a new message has been added to the conversation on the server.
     *
     * Parameters:
     * 1. {@link Message} `message` - the message in question
     * @event
     */
    static readonly messageAdded = "messageAdded";
    /**
     * Fired when a message is removed from the message list of a conversation.
     *
     * Parameters:
     * 1. {@link Message} `message` - the message in question
     * @event
     */
    static readonly messageRemoved = "messageRemoved";
    /**
     * Fired when the fields of an existing message are updated with new values.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Message} `message` - the message in question
     *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    static readonly messageUpdated = "messageUpdated";
    /**
     * Fired when the token is about to expire and needs to be updated.
     * * Parameters:
     * 1. number `message` - token's time to live
     * @event
     */
    static readonly tokenAboutToExpire = "tokenAboutToExpire";
    /**
     * Fired when the token has expired.
     * @event
     */
    static readonly tokenExpired = "tokenExpired";
    /**
     * Fired when a participant has stopped typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly typingEnded = "typingEnded";
    /**
     * Fired when a participant has started typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly typingStarted = "typingStarted";
    /**
     * Fired when the client has received (and parsed) a push notification via one of the push channels (apn or fcm).
     *
     * Parameters:
     * 1. {@link PushNotification} `pushNotification` - the push notification in question
     * @event
     */
    static readonly pushNotification = "pushNotification";
    /**
     * Fired when the client has subscribed to a user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    static readonly userSubscribed = "userSubscribed";
    /**
     * Fired when the client has unsubscribed from a user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    static readonly userUnsubscribed = "userUnsubscribed";
    /**
     * Fired when the properties or the reachability status of a user have been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link User} `user` - the user in question
     *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    static readonly userUpdated = "userUpdated";
    /**
     * Fired when the state of the client has been changed.
     *
     * Parameters:
     * 1. {@link State} `state` - the new client state
     * @event
     */
    static readonly stateChanged = "stateChanged";
    /**
     * Fired when the connection state of the client has been changed.
     *
     * Paremeters:
     * 1. {@link ConnectionState} `state` - the new connection state
     * @event
     */
    static readonly connectionStateChanged = "connectionStateChanged";
    /**
     * Fired when the connection is interrupted for an unexpected reason.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * boolean `terminal` - Twilsock will stop connection attempts if true
     *     * string `message` - the error message of the root cause
     *     * number? `httpStatusCode` - http status code if available
     *     * number? `errorCode` - Twilio public error code if available
     * @event
     */
    static readonly connectionError = "connectionError";
    /**
     * @deprecated Call constructor directly.
     *
     * Factory method to create a Conversations client instance.
     *
     * The factory method will automatically trigger connection.
     * Do not use it if you need finer-grained control.
     *
     * Since this method returns an already-initialized client, some of the events
     * will be lost because they happen *before* the initialization. It is
     * recommended that `client.onWithReplay` is used as opposed to `client.on`
     * for subscribing to client events. The `client.onWithReplay` will re-emit
     * the most recent value for a given event if it emitted before the
     * subscription.
     *
     * @param token Access token.
     * @param options Options to customize the client.
     * @returns Returns a fully initialized client.
     */
    static create(token: string, options?: ClientOptions | null): Promise<Client>;
    /**
     * Information of the logged-in user. Before client initialization, returns an
     * uninitialized user. Will trigger a {@link Client.userUpdated} event after
     * initialization.
     */
    get user(): User;
    /**
     * Client reachability state. Throws if accessed before the client
     * initialization was completed.
     */
    get reachabilityEnabled(): boolean;
    get token(): string;
    private _subscribeToPushNotifications;
    private _unsubscribeFromPushNotifications;
    private _initialize;
    /**
     * Gracefully shut down the client.
     */
    shutdown(): Promise<void>;
    /**
     * Update the token used by the client and re-register with the Conversations services.
     * @param token New access token.
     */
    updateToken(token: string): Promise<Client>;
    /**
     * Get a known conversation by its SID.
     * @param conversationSid Conversation sid
     */
    getConversationBySid(conversationSid: string): Promise<Conversation>;
    /**
     * Get a known conversation by its unique identifier name.
     * @param uniqueName The unique identifier name of the conversation.
     */
    getConversationByUniqueName(uniqueName: string): Promise<Conversation>;
    /**
     * Get the current list of all the subscribed conversations.
     */
    getSubscribedConversations(): Promise<Paginator<Conversation>>;
    /**
     * Create a conversation on the server and subscribe to its events.
     * The default is a conversation with an empty friendly name.
     * @param options Options for the conversation.
     */
    createConversation(options?: CreateConversationOptions): Promise<Conversation>;
    /**
     * Register for push notifications.
     * @param channelType Channel type.
     * @param registrationId Push notification ID provided by the FCM/APNS service on the platform.
     */
    setPushRegistrationId(channelType: NotificationsChannelType, registrationId: string): Promise<void>;
    /**
     * Unregister from push notifications.
     * @param channelType Channel type.
     * @deprecated Use removePushRegistrations() instead.
     */
    unsetPushRegistrationId(channelType: NotificationsChannelType): Promise<void>;
    /**
     * Clear existing registrations directly using provided device token.
     * This is useful to ensure stopped subscriptions without resubscribing.
     *
     * This function goes completely beside the state machine and removes all registrations.
     * Use with caution: if it races with current state machine operations, madness will ensue.
     *
     * @param channelType Channel type.
     * @param registrationId Push notification ID provided by the FCM/APNS service on the platform.
     */
    removePushRegistrations(channelType: ChannelType, registrationId: string): Promise<void>;
    private static parsePushNotificationChatData;
    /**
     * Static method for push notification payload parsing. Returns parsed push as a {@link PushNotification} object.
     * @param notificationPayload Push notification payload.
     */
    static parsePushNotification(notificationPayload: any): PushNotification;
    parsePushNotification: typeof Client.parsePushNotification;
    /**
     * Handle push notification payload parsing and emit the {@link Client.pushNotification} event on this {@link Client} instance.
     * @param notificationPayload Push notification payload
     */
    handlePushNotification(notificationPayload: any): Promise<void>;
    /**
     * Gets a user with the given identity. If it's in the subscribed list, then return the user object from it;
     * if not, then subscribe and add user to the subscribed list.
     * @param identity Identity of the user.
     * @returns A fully initialized user.
     */
    getUser(identity: string): Promise<User>;
    /**
     * Get a list of subscribed user objects.
     */
    getSubscribedUsers(): Promise<Array<User>>;
}
declare class NotificationTypes {
    static readonly TYPING_INDICATOR = "twilio.ipmsg.typing_indicator";
    static readonly NEW_MESSAGE = "twilio.conversations.new_message";
    static readonly ADDED_TO_CONVERSATION = "twilio.conversations.added_to_conversation";
    // static readonly INVITED_TO_CHANNEL = 'twilio.channel.invited_to_channel';
    static readonly REMOVED_FROM_CONVERSATION = "twilio.conversations.removed_from_conversation";
    static readonly CONSUMPTION_UPDATE = "twilio.channel.consumption_update";
}
export { Conversation, ConversationBindings, ConversationEmailBinding, ConversationUpdateReason, ConversationStatus, NotificationLevel, ConversationState, ConversationUpdatedEventArgs, SendMediaOptions, SendEmailOptions, LastMessage, Participant, ParticipantUpdateReason, ParticipantType, ParticipantUpdatedEventArgs, ParticipantBindings, ParticipantEmailBinding, ParticipantEmailLevel, Message, MessageUpdateReason, MessageType, MessageUpdatedEventArgs, Media, MediaCategory$0 as MediaCategory, AggregatedDeliveryReceipt, DeliveryAmount, DetailedDeliveryReceipt, DeliveryStatus, RestPaginator, MessageBuilder, UnsentMessage, Paginator, ParticipantBindingOptions, User, UserUpdateReason, UserUpdatedEventArgs, PushNotification, PushNotificationType, PushNotificationDescriptor, PushNotificationData, NotificationTypes, Client, State, ConnectionState, NotificationsChannelType, ClientOptions, CreateConversationOptions, ConversationLimits, JSONValue, JSONObject, JSONArray };
