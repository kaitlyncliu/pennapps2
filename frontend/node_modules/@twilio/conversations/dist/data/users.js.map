{"version":3,"file":"users.js","sources":["../../src/data/users.ts"],"sourcesContent":["import { User, UserUpdatedEventArgs, UserUpdateReason } from \"../user\";\nimport { Network } from \"../services/network\";\nimport { SyncClient } from \"twilio-sync\";\nimport { UriBuilder } from \"../util\";\nimport { Configuration } from \"../configuration\";\nimport { CommandExecutor } from \"../command-executor\";\nimport { ReplayEventEmitter } from \"@twilio/replay-event-emitter\";\nimport { UserResponse } from \"../interfaces/commands/user\";\n\ntype UsersEvents = {\n  userUpdated: (data: {\n    user: User;\n    updateReasons: UserUpdateReason[];\n  }) => void;\n  userSubscribed: (user: User) => void;\n  userUnsubscribed: (user: User) => void;\n};\n\nexport interface UsersServices {\n  network: Network;\n  syncClient: SyncClient;\n  commandExecutor: CommandExecutor;\n}\n\n/**\n * Container for known users\n */\nclass Users extends ReplayEventEmitter<UsersEvents> {\n  private readonly configuration: Configuration;\n  private readonly services: UsersServices;\n\n  private subscribedUsers: Map<string, User>;\n  private fifoStack: string[];\n  public readonly myself: User;\n\n  constructor(\n    myself: User,\n    configuration: Configuration,\n    services: UsersServices\n  ) {\n    super();\n\n    this.configuration = configuration;\n    this.services = services;\n\n    this.fifoStack = [];\n    this.myself = myself;\n    this.myself.on(\"updated\", (args: UserUpdatedEventArgs) =>\n      this.emit(\"userUpdated\", args)\n    );\n    this.myself.on(\"userSubscribed\", () =>\n      this.emit(\"userSubscribed\", this.myself)\n    );\n    this.myself.on(\"userUnsubscribed\", () => {\n      this.emit(\"userUnsubscribed\", this.myself);\n      this.myself._ensureFetched();\n    });\n\n    this.subscribedUsers = new Map<string, User>();\n  }\n\n  private handleUnsubscribeUser(user: User): void {\n    if (this.subscribedUsers.has(user.identity)) {\n      this.subscribedUsers.delete(user.identity);\n    }\n    let foundItemIndex = 0;\n    const foundItem = this.fifoStack.find((item, index) => {\n      if (item == user.identity) {\n        foundItemIndex = index;\n        return true;\n      }\n      return false;\n    });\n    if (foundItem) {\n      this.fifoStack.splice(foundItemIndex, 1);\n    }\n    this.emit(\"userUnsubscribed\", user);\n  }\n\n  private handleSubscribeUser(user: User): void {\n    if (this.subscribedUsers.has(user.identity)) {\n      return;\n    }\n    if (this.fifoStack.length >= this.configuration.userInfosToSubscribe) {\n      const item = this.fifoStack.shift() as string;\n      this.subscribedUsers?.get(item)?.unsubscribe();\n    }\n    this.fifoStack.push(user.identity);\n    this.subscribedUsers.set(user.identity, user);\n    this.emit(\"userSubscribed\", user);\n  }\n\n  /**\n   * Gets user, if it's in subscribed list - then return the user object from it,\n   * if not - then subscribes and adds user to the FIFO stack\n   * @returns {Promise<User>} Fully initialized user\n   */\n  async getUser(identity = \"\", entityName = \"\"): Promise<User> {\n    await this.myself._ensureFetched();\n\n    if (identity == this.myself.identity) {\n      return this.myself;\n    }\n\n    const user = this.subscribedUsers.get(identity);\n\n    if (user) {\n      return user;\n    }\n\n    entityName = entityName || (await this.getSyncUniqueName(identity));\n\n    const newUser = new User(\n      identity,\n      entityName,\n      this.configuration,\n      this.services\n    );\n\n    newUser.on(\"updated\", (args: UserUpdatedEventArgs) =>\n      this.emit(\"userUpdated\", args)\n    );\n    newUser.on(\"userSubscribed\", () => this.handleSubscribeUser(newUser));\n    newUser.on(\"userUnsubscribed\", () => this.handleUnsubscribeUser(newUser));\n    await newUser._ensureFetched();\n\n    return newUser;\n  }\n\n  /**\n   * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}\n   */\n  async getSubscribedUsers(): Promise<Array<User>> {\n    await this.myself._ensureFetched();\n\n    const users = [this.myself];\n    this.subscribedUsers.forEach((user) => users.push(user));\n\n    return users;\n  }\n\n  /**\n   * @returns {Promise<string>} User's sync unique name\n   */\n  private async getSyncUniqueName(identity: string): Promise<string> {\n    const url = new UriBuilder(this.configuration.links.users)\n      .path(identity)\n      .build();\n    const response = await this.services.network.get<UserResponse>(url);\n    return response.body?.sync_objects.user_info_map ?? \"\";\n  }\n}\n\nexport { Users };\n"],"names":["ReplayEventEmitter","user","User","UriBuilder"],"mappings":"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"}