{"version":3,"file":"participant.js","sources":["../src/participant.ts"],"sourcesContent":["import { Users } from \"./data/users\";\nimport { User } from \"./user\";\nimport { parseTime, parseAttributes } from \"./util\";\nimport { Logger } from \"./logger\";\nimport { Conversation } from \"./conversation\";\nimport { attributesValidator } from \"./interfaces/attributes\";\nimport { validateTypesAsync } from \"@twilio/declarative-type-validator\";\nimport { CommandExecutor } from \"./command-executor\";\nimport { EditParticipantRequest } from \"./interfaces/commands/edit-participant\";\nimport { ParticipantResponse } from \"./interfaces/commands/participant-response\";\nimport { ReplayEventEmitter } from \"@twilio/replay-event-emitter\";\nimport isEqual from \"lodash.isequal\";\nimport { JSONValue } from \"./types\";\n\ntype ParticipantEvents = {\n  typingEnded: (participant: Participant) => void;\n  typingStarted: (participant: Participant) => void;\n  updated: (data: {\n    participant: Participant;\n    updateReasons: ParticipantUpdateReason[];\n  }) => void;\n};\n\nconst log = Logger.scope(\"Participant\");\n\ninterface ParticipantDescriptor {\n  attributes?: JSONValue;\n  dateCreated: Date | null;\n  dateUpdated: Date | null;\n  identity: string;\n  roleSid?: string;\n  lastConsumedMessageIndex: number | null;\n  lastConsumptionTimestamp: number;\n  type: ParticipantType;\n  userInfo: string;\n  bindings?: ParticipantBindings;\n}\n\ninterface ParticipantState {\n  attributes: JSONValue;\n  dateCreated: Date | null;\n  dateUpdated: Date | null;\n  identity: string;\n  isTyping: boolean;\n  lastReadMessageIndex: number | null;\n  lastReadTimestamp: Date | null;\n  roleSid: string;\n  sid: string;\n  type: ParticipantType;\n  typingTimeout: number | null;\n  userInfo: string;\n  bindings?: ParticipantBindings;\n}\n\ninterface ParticipantServices {\n  users: Users;\n  commandExecutor: CommandExecutor;\n}\n\ninterface ParticipantLinks {\n  self: string;\n}\n\n/**\n * The reason for the `updated` event being emitted by a participant.\n */\ntype ParticipantUpdateReason =\n  | \"attributes\"\n  | \"dateCreated\"\n  | \"dateUpdated\"\n  | \"roleSid\"\n  | \"lastReadMessageIndex\"\n  | \"lastReadTimestamp\"\n  | \"bindings\";\n\n/**\n * Type of a participant.\n */\ntype ParticipantType = \"chat\" | \"sms\" | \"whatsapp\" | \"email\";\n\ninterface ParticipantUpdatedEventArgs {\n  participant: Participant;\n  updateReasons: ParticipantUpdateReason[];\n}\n\n/**\n * Bindings for conversation participant.\n */\ninterface ParticipantBindings {\n  email?: ParticipantEmailBinding;\n}\n\n/**\n * Email participation level.\n * to = to/from\n * cc = cc\n */\ntype ParticipantEmailLevel = \"to\" | \"cc\";\n\n/**\n * Bindings for email participant.\n */\ninterface ParticipantEmailBinding {\n  name: string;\n  address: string;\n  level: ParticipantEmailLevel;\n}\n\n/**\n * A participant represents a remote client in a conversation.\n */\nclass Participant extends ReplayEventEmitter<ParticipantEvents> {\n  private state: ParticipantState;\n  private readonly links: ParticipantLinks;\n  private readonly services: ParticipantServices;\n\n  /**\n   * Conversation that the remote client is a participant of.\n   */\n  public readonly conversation: Conversation;\n\n  /**\n   * The server-assigned unique identifier for the participant.\n   */\n  public get sid(): string {\n    return this.state.sid;\n  }\n\n  /**\n   * Custom attributes of the participant.\n   */\n  public get attributes(): JSONValue {\n    return this.state.attributes;\n  }\n\n  /**\n   * Date this participant was created on.\n   */\n  public get dateCreated(): Date | null {\n    return this.state.dateCreated;\n  }\n\n  /**\n   * Date this participant was last updated on.\n   */\n  public get dateUpdated(): Date | null {\n    return this.state.dateUpdated;\n  }\n\n  /**\n   * Identity of the participant.\n   */\n  public get identity(): string | null {\n    return this.state.identity;\n  }\n\n  /**\n   * Indicates whether the participant is currently typing.\n   */\n  public get isTyping(): boolean {\n    return this.state.isTyping;\n  }\n\n  /**\n   * The index of the last read message by the participant.\n   * Note that retrieving messages on a client endpoint does not mean that messages are read,\n   * please consider reading about the [Read Horizon feature](https://www.twilio.com/docs/api/chat/guides/consumption-horizon)\n   * to find out about the proper way to mark messages as read.\n   */\n  public get lastReadMessageIndex(): number | null {\n    return this.state.lastReadMessageIndex;\n  }\n\n  /**\n   * Date of the most recent read horizon update.\n   */\n  public get lastReadTimestamp(): Date | null {\n    return this.state.lastReadTimestamp;\n  }\n\n  public get roleSid(): string {\n    return this.state.roleSid;\n  }\n\n  /**\n   * Type of the participant.\n   */\n  public get type(): ParticipantType {\n    return this.state.type;\n  }\n\n  /**\n   * Get the bindings mapping for the current participant.\n   * Available binding depends on the participant type.\n   * You could access it as `participant.bindings.sms?.address` or\n   * using the type dynamically `participant.bindings[participant.type]`\n   * just be aware that the binding information has different structure for\n   * each participant type.\n   * See also {ParticipantEmailBinding}, the only available currently binding descriptor.\n   */\n  public get bindings(): ParticipantBindings {\n    return this.state.bindings ?? {};\n  }\n\n  /**\n   * @internal\n   */\n  constructor(\n    data: ParticipantDescriptor,\n    sid: string,\n    conversation: Conversation,\n    links: ParticipantLinks,\n    services: ParticipantServices\n  ) {\n    super();\n\n    this.conversation = conversation;\n    this.links = links;\n    this.services = services;\n    this.state = {\n      attributes: parseAttributes(\n        data.attributes,\n        \"Retrieved malformed attributes from the server for participant: \" +\n          sid,\n        log\n      ),\n      dateCreated: data.dateCreated ? parseTime(data.dateCreated) : null,\n      dateUpdated: data.dateCreated ? parseTime(data.dateUpdated) : null,\n      sid: sid,\n      typingTimeout: null,\n      isTyping: false,\n      identity: data.identity,\n      roleSid: data.roleSid ?? \"\",\n      lastReadMessageIndex: Number.isInteger(data.lastConsumedMessageIndex)\n        ? data.lastConsumedMessageIndex\n        : null,\n      lastReadTimestamp: data.lastConsumptionTimestamp\n        ? parseTime(data.lastConsumptionTimestamp)\n        : null,\n      type: data.type || \"chat\",\n      userInfo: data.userInfo,\n      bindings: data.bindings ?? {},\n    };\n\n    if (!data.identity && !data.type) {\n      throw new Error(\n        \"Received invalid Participant object from server: Missing identity or type of Participant.\"\n      );\n    }\n  }\n\n  /**\n   * Fired when the participant has started typing.\n   *\n   * Parameters:\n   * 1. {@link Participant} `participant` - the participant in question\n   * @event\n   */\n  static readonly typingStarted = \"typingStarted\";\n\n  /**\n   * Fired when the participant has stopped typing.\n   *\n   * Parameters:\n   * 1. {@link Participant} `participant` - the participant in question\n   * @event\n   */\n  static readonly typingEnded = \"typingEnded\";\n\n  /**\n   * Fired when the fields of the participant have been updated.\n   *\n   * Parameters:\n   * 1. object `data` - info object provided with the event. It has the following properties:\n   *     * {@link Participant} participant - the participant in question\n   *     * {@link ParticipantUpdateReason}[] updateReasons - array of reasons for the update\n   * @event\n   */\n  static readonly updated = \"updated\";\n\n  /**\n   * Internal method used to start or reset the typing indicator timeout (with event emitting).\n   * @internal\n   */\n  _startTyping(timeout) {\n    if (this.state.typingTimeout) {\n      clearTimeout(this.state.typingTimeout);\n    }\n\n    this.state.isTyping = true;\n    this.emit(\"typingStarted\", this);\n\n    this.conversation.emit(\"typingStarted\", this);\n\n    this.state.typingTimeout = Number(\n      setTimeout(() => this._endTyping(), timeout)\n    );\n    return this;\n  }\n\n  /**\n   * Internal method function used to stop the typing indicator timeout (with event emitting).\n   * @internal\n   */\n  _endTyping() {\n    if (!this.state.typingTimeout) {\n      return;\n    }\n\n    this.state.isTyping = false;\n    this.emit(\"typingEnded\", this);\n\n    this.conversation.emit(\"typingEnded\", this);\n\n    clearInterval(this.state.typingTimeout);\n    this.state.typingTimeout = null;\n  }\n\n  /**\n   * Internal method function used update local object's property roleSid with a new value.\n   * @internal\n   */\n  _update(data) {\n    const updateReasons: ParticipantUpdateReason[] = [];\n\n    const updateAttributes = parseAttributes(\n      data.attributes,\n      \"Retrieved malformed attributes from the server for participant: \" +\n        this.state.sid,\n      log\n    );\n\n    if (data.attributes && !isEqual(this.state.attributes, updateAttributes)) {\n      this.state.attributes = updateAttributes;\n      updateReasons.push(\"attributes\");\n    }\n\n    const updatedDateUpdated = parseTime(data.dateUpdated);\n    if (\n      data.dateUpdated &&\n      updatedDateUpdated?.getTime() !==\n        (this.state.dateUpdated && this.state.dateUpdated.getTime())\n    ) {\n      this.state.dateUpdated = updatedDateUpdated;\n      updateReasons.push(\"dateUpdated\");\n    }\n\n    const updatedDateCreated = parseTime(data.dateCreated);\n    if (\n      data.dateCreated &&\n      updatedDateCreated?.getTime() !==\n        (this.state.dateCreated && this.state.dateCreated.getTime())\n    ) {\n      this.state.dateCreated = updatedDateCreated;\n      updateReasons.push(\"dateCreated\");\n    }\n\n    if (data.roleSid && this.state.roleSid !== data.roleSid) {\n      this.state.roleSid = data.roleSid;\n      updateReasons.push(\"roleSid\");\n    }\n\n    if (\n      (Number.isInteger(data.lastConsumedMessageIndex) ||\n        data.lastConsumedMessageIndex === null) &&\n      this.state.lastReadMessageIndex !== data.lastConsumedMessageIndex\n    ) {\n      this.state.lastReadMessageIndex = data.lastConsumedMessageIndex;\n      updateReasons.push(\"lastReadMessageIndex\");\n    }\n\n    if (data.lastConsumptionTimestamp) {\n      const lastReadTimestamp = new Date(data.lastConsumptionTimestamp);\n      if (\n        !this.state.lastReadTimestamp ||\n        this.state.lastReadTimestamp.getTime() !== lastReadTimestamp.getTime()\n      ) {\n        this.state.lastReadTimestamp = lastReadTimestamp;\n        updateReasons.push(\"lastReadTimestamp\");\n      }\n    }\n\n    if (data.bindings && !isEqual(this.state.bindings, data.bindings)) {\n      this.state.bindings = data.bindings;\n      updateReasons.push(\"bindings\");\n    }\n\n    if (updateReasons.length > 0) {\n      this.emit(\"updated\", { participant: this, updateReasons: updateReasons });\n    }\n\n    return this;\n  }\n\n  /**\n   * Get the user for this participant and subscribes to it. Supported only for participants of type `chat`.\n   */\n  async getUser(): Promise<User> {\n    if (this.type != \"chat\") {\n      throw new Error(\n        \"Getting User is not supported for this Participant type: \" + this.type\n      );\n    }\n\n    return this.services.users.getUser(\n      this.state.identity,\n      this.state.userInfo\n    );\n  }\n\n  /**\n   * Remove the participant from the conversation.\n   */\n  async remove() {\n    return this.conversation.removeParticipant(this);\n  }\n\n  /**\n   * Update the attributes of the participant.\n   * @param attributes New attributes.\n   */\n  @validateTypesAsync(attributesValidator)\n  async updateAttributes(attributes: JSONValue): Promise<Participant> {\n    await this.services.commandExecutor.mutateResource<\n      EditParticipantRequest,\n      ParticipantResponse\n    >(\"post\", this.links.self, {\n      attributes: JSON.stringify(attributes),\n    });\n\n    return this;\n  }\n}\n\nexport {\n  ParticipantDescriptor,\n  ParticipantServices,\n  Participant,\n  ParticipantUpdateReason,\n  ParticipantType,\n  ParticipantUpdatedEventArgs,\n  ParticipantBindings,\n  ParticipantEmailBinding,\n  ParticipantEmailLevel,\n};\n"],"names":["Logger","ReplayEventEmitter","parseAttributes","parseTime","isEqual","__decorate","validateTypesAsync","attributesValidator"],"mappings":"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"}