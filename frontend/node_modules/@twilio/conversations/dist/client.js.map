{"version":3,"file":"client.js","sources":["../src/client.ts"],"sourcesContent":["import { Logger } from \"./logger\";\nimport { Configuration } from \"./configuration\";\n\nimport { User, UserUpdatedEventArgs, UserUpdateReason } from \"./user\";\nimport { Network } from \"./services/network\";\n\nimport { NotificationTypes } from \"./interfaces/notification-types\";\n\nimport {\n  TwilsockClient,\n  InitRegistration,\n  ConnectionState as TwilsockConnectionState,\n  Transport,\n} from \"twilsock\";\nimport {\n  ChannelType,\n  Notifications as NotificationClient,\n} from \"@twilio/notifications\";\nimport { SyncClient } from \"twilio-sync\";\nimport { McsClient } from \"@twilio/mcs-client\";\n\nimport {\n  Conversation,\n  Conversations,\n  Conversations as ConversationsEntity,\n} from \"./data/conversations\";\n\nimport { Users } from \"./data/users\";\nimport { TypingIndicator } from \"./services/typing-indicator\";\nimport { Paginator } from \"./interfaces/paginator\";\nimport { PushNotification } from \"./push-notification\";\nimport { deepClone, parseToNumber } from \"./util\";\nimport {\n  Participant,\n  ParticipantUpdatedEventArgs,\n  ParticipantUpdateReason,\n} from \"./participant\";\nimport {\n  Message,\n  MessageUpdatedEventArgs,\n  MessageUpdateReason,\n} from \"./message\";\nimport { TelemetryEventDescription, TelemetryPoint } from \"twilsock\";\nimport {\n  validateTypesAsync,\n  validateTypes,\n  literal,\n  nonEmptyString,\n  pureObject,\n  objectSchema,\n  validateConstructorTypes,\n} from \"@twilio/declarative-type-validator\";\nimport { version } from \"../package.json\";\nimport {\n  ConversationUpdatedEventArgs,\n  ConversationUpdateReason,\n} from \"./conversation\";\nimport { CommandExecutor } from \"./command-executor\";\nimport { ConfigurationResponse } from \"./interfaces/commands/configuration\";\nimport { ReplayEventEmitter } from \"@twilio/replay-event-emitter\";\nimport { JSONValue } from \"./types\";\n\nconst log = Logger.scope(\"Client\");\n\nconst SDK_VERSION = version;\n\nclass ClientServices {\n  commandExecutor!: CommandExecutor;\n  twilsockClient!: TwilsockClient;\n  users!: Users;\n  notificationClient!: NotificationClient;\n  network!: Network;\n  typingIndicator!: TypingIndicator;\n  syncClient!: SyncClient;\n  mcsClient!: McsClient;\n  transport!: Transport;\n}\n\ntype ClientEvents = {\n  conversationAdded: (conversation: Conversation) => void;\n  conversationJoined: (conversation: Conversation) => void;\n  conversationLeft: (conversation: Conversation) => void;\n  conversationRemoved: (conversation: Conversation) => void;\n  conversationUpdated: (data: {\n    conversation: Conversation;\n    updateReasons: ConversationUpdateReason[];\n  }) => void;\n  participantJoined: (participant: Participant) => void;\n  participantLeft: (participant: Participant) => void;\n  participantUpdated: (data: {\n    participant: Participant;\n    updateReasons: ParticipantUpdateReason[];\n  }) => void;\n  messageAdded: (message: Message) => void;\n  messageRemoved: (message: Message) => void;\n  messageUpdated: (data: {\n    message: Message;\n    updateReasons: MessageUpdateReason[];\n  }) => void;\n  tokenAboutToExpire: (ttl: number) => void;\n  tokenExpired: () => void;\n  typingEnded: (participant: Participant) => void;\n  typingStarted: (participant: Participant) => void;\n  pushNotification: (pushNotification: PushNotification) => void;\n  userSubscribed: (user: User) => void;\n  userUnsubscribed: (user: User) => void;\n  userUpdated: (data: {\n    user: User;\n    updateReasons: UserUpdateReason[];\n  }) => void;\n  stateChanged: (state: State) => void;\n  connectionStateChanged: (state: TwilsockConnectionState) => void;\n  connectionError: (data: {\n    terminal: boolean;\n    message: string;\n    httpStatusCode?: number;\n    errorCode?: number;\n  }) => void;\n};\n\n/**\n * Connection state of the client. Possible values are as follows:\n * * `'connecting'` - client is offline and connection attempt is in process\n * * `'connected'` - client is online and ready\n * * `'disconnecting'` - client is going offline as disconnection is in process\n * * `'disconnected'` - client is offline and no connection attempt is in process\n * * `'denied'` - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed\n */\ntype ConnectionState = TwilsockConnectionState;\n\n/**\n * State of the client. Possible values are as follows:\n * * `'failed'` - the client failed to initialize\n * * `'initialized'` - the client successfully initialized\n */\ntype State = \"failed\" | \"initialized\";\n\n/**\n * Notifications channel type. Possible values are as follows:\n * * `'fcm'`\n * * `'apn'`\n */\ntype NotificationsChannelType = ChannelType;\n\ntype LogLevel = \"trace\" | \"debug\" | \"info\" | \"warn\" | \"error\" | \"silent\";\n\n/**\n * Conversations client options.\n */\ninterface ClientOptions {\n  /**\n   * The level of logging to enable.\n   */\n  logLevel?: LogLevel;\n  region?: string;\n  productId?: string;\n  twilsockClient?: TwilsockClient;\n  transport?: Transport;\n  notificationsClient?: NotificationClient;\n  syncClient?: SyncClient;\n  typingIndicatorTimeoutOverride?: number;\n  consumptionReportIntervalOverride?: string;\n  httpCacheIntervalOverride?: string;\n  userInfosToSubscribeOverride?: number;\n  retryWhenThrottledOverride?: boolean;\n  backoffConfigOverride?: Record<string, unknown>;\n  Chat?: ClientOptions;\n  IPMessaging?: ClientOptions;\n  Sync?: Record<string, unknown>;\n  Notification?: Record<string, unknown>;\n  Twilsock?: Record<string, unknown>;\n  clientMetadata?: Record<string, unknown>;\n  initRegistrations?: InitRegistration[];\n  disableDeepClone?: boolean;\n  typingUri?: string;\n  apiUri?: string;\n}\n\n/**\n * Options for {@link Client.createConversation}.\n */\ninterface CreateConversationOptions {\n  /**\n   * Any custom attributes to attach to the conversation.\n   */\n  attributes?: JSONValue;\n\n  /**\n   * A non-unique display name of the conversation.\n   */\n  friendlyName?: string;\n\n  /**\n   * A unique identifier of the conversation.\n   */\n  uniqueName?: string;\n}\n\n/**\n * A client is the starting point to the Twilio Conversations functionality.\n */\n@validateConstructorTypes(nonEmptyString, [pureObject, \"undefined\"])\nclass Client extends ReplayEventEmitter<ClientEvents> {\n  /**\n   * Client connection state.\n   */\n  public connectionState: ConnectionState = \"unknown\";\n  private conversationsPromise!: Promise<Conversations>;\n  private _ensureReady!: Promise<void>;\n  private _resolveEnsureReady!: () => void;\n  private _rejectEnsureReady!: (err: Error) => void;\n  private fpaToken: string;\n  private configuration!: Configuration;\n  private conversations!: Conversations;\n  private readonly options: Partial<ClientOptions>;\n  private services: ClientServices;\n  private readonly _myself: User;\n\n  /**\n   * Current version of the Conversations client.\n   */\n  public static readonly version: string = SDK_VERSION;\n\n  /**\n   * Current version of the Conversations client.\n   */\n  public readonly version: string = SDK_VERSION;\n\n  private static readonly supportedPushChannels: NotificationsChannelType[] = [\n    \"fcm\",\n    \"apn\",\n  ];\n  private static readonly supportedPushDataFields = {\n    conversation_sid: \"conversationSid\",\n    message_sid: \"messageSid\",\n    message_index: \"messageIndex\",\n  };\n\n  /**\n   * Returned Conversations instance is not yet fully initialized. Calling any operations will block until it is.\n   * Use connection events to monitor when client becomes fully available (connectionStateChanged with state\n   * 'connected') or not available (connectionStateChange with state 'denied', event tokenExpired, event connectionError).\n   *\n   * @param fpaToken Access token\n   * @param options Options to customize the Client\n   * @returns A not yet fully-initialized client.\n   */\n  public constructor(fpaToken: string, options: ClientOptions | null = {}) {\n    super();\n\n    this.fpaToken = fpaToken ?? \"\";\n    this.options = options ?? {};\n\n    if (!this.options.disableDeepClone) {\n      let options: Partial<ClientOptions> = {\n        ...this.options,\n        transport: undefined,\n        twilsockClient: undefined,\n      };\n\n      options = deepClone(options);\n      options.transport = this.options.transport;\n      options.twilsockClient = this.options.twilsockClient;\n\n      this.options = options;\n    }\n\n    this.options.logLevel = this.options.logLevel ?? \"silent\";\n    log.setLevel(this.options.logLevel);\n\n    const productId = (this.options.productId = \"ip_messaging\");\n\n    // Filling ClientMetadata\n    this.options.clientMetadata = this.options.clientMetadata || {};\n\n    if (!this.options.clientMetadata.hasOwnProperty(\"type\")) {\n      this.options.clientMetadata.type = \"conversations\";\n    }\n\n    if (!this.options.clientMetadata.hasOwnProperty(\"sdk\")) {\n      this.options.clientMetadata.sdk = \"JS\";\n      this.options.clientMetadata.sdkv = SDK_VERSION;\n    }\n\n    // Enable session local storage for Sync\n    this.options.Sync = this.options.Sync || {};\n\n    if (typeof this.options.Sync.enableSessionStorage === \"undefined\") {\n      this.options.Sync.enableSessionStorage = true;\n    }\n\n    if (this.options.region) {\n      this.options.Sync.region = this.options.region;\n    }\n\n    if (!fpaToken) {\n      throw new Error(\"A valid Twilio token should be provided\");\n    }\n\n    this.services = new ClientServices();\n\n    this._myself = new User(\"\", \"\", null, this.services);\n\n    const startTwilsock = !this.options.twilsockClient;\n\n    // Create default init registrations if none were provided.\n    // Otherwise, the outside party have to list all the init registrations they\n    // need.\n    // Init registrations passed to the Conversations client will be passed down\n    // to the Sync client as well.\n    if (!this.options.initRegistrations) {\n      const initRegistration = new InitRegistration(productId);\n      Client.populateInitRegistrations(initRegistration);\n      this.options.initRegistrations = [initRegistration];\n    }\n\n    this.services.twilsockClient = this.options.twilsockClient =\n      this.options.twilsockClient ??\n      new TwilsockClient(fpaToken, productId, this.options);\n\n    this.services.twilsockClient.on(\"tokenAboutToExpire\", (ttl) =>\n      this.emit(\"tokenAboutToExpire\", ttl)\n    );\n    this.services.twilsockClient.on(\"tokenExpired\", () =>\n      this.emit(\"tokenExpired\")\n    );\n    this.services.twilsockClient.on(\"connectionError\", (error) =>\n      this.emit(\"connectionError\", error)\n    );\n    this.services.twilsockClient.on(\n      \"stateChanged\",\n      (state: ConnectionState) => {\n        log.debug(\n          `Handling stateChanged for ConversationsClient: new state ${state}`\n        );\n        if (state !== this.connectionState) {\n          this.connectionState = state;\n          this.emit(\"connectionStateChanged\", this.connectionState);\n        }\n      }\n    );\n\n    this.services.transport = this.options.transport = (this.options\n      .transport ?? this.options.twilsockClient) as Transport;\n    this.services.notificationClient = this.options.notificationsClient =\n      this.options.notificationsClient ??\n      new NotificationClient(fpaToken, this.options);\n    this.services.syncClient = this.options.syncClient =\n      this.options.syncClient ?? new SyncClient(fpaToken, this.options);\n\n    const configurationOptions =\n      options?.Chat || options?.IPMessaging || options || {};\n    const region = configurationOptions.region || options?.region;\n    const baseUrl: string =\n      configurationOptions.apiUri ||\n      configurationOptions.typingUri ||\n      `https://aim.${region || \"us1\"}.twilio.com`;\n\n    this.services.commandExecutor = new CommandExecutor(\n      baseUrl,\n      { transport: this.options.transport },\n      productId\n    );\n\n    const emitFailed = (err): void => {\n      this._rejectEnsureReady(err);\n      this.emit(\"stateChanged\", \"failed\");\n    };\n\n    this.services.twilsockClient.once(\"connectionError\", emitFailed);\n    this.services.twilsockClient.once(\"disconnected\", emitFailed);\n\n    // ConversationsClient will be able to initialize only after twilsock is connected\n    this.services.twilsockClient.once(\"connected\", async () => {\n      log.debug(`ConversationsClient started INITIALIZING`);\n      this.services.twilsockClient.off(\"connectionError\", emitFailed);\n      this.services.twilsockClient.off(\"disconnected\", emitFailed);\n      try {\n        const startupEvent = \"conversations.client.startup\";\n\n        this.services.twilsockClient.addPartialTelemetryEvent(\n          new TelemetryEventDescription(\n            startupEvent,\n            \"Conversations client startup\",\n            new Date()\n          ),\n          startupEvent,\n          TelemetryPoint.Start\n        );\n\n        await this._initialize();\n\n        this.services.twilsockClient.addPartialTelemetryEvent(\n          new TelemetryEventDescription(\"\", \"\", new Date()),\n          startupEvent,\n          TelemetryPoint.End\n        );\n      } catch (err) {\n        // Fail ChatClient if initialization is incomplete\n        this._rejectEnsureReady(err);\n        this.emit(\"stateChanged\", \"failed\");\n      }\n    });\n\n    this._ensureReady = new Promise<void>((resolve, reject) => {\n      this._resolveEnsureReady = resolve;\n      this._rejectEnsureReady = reject;\n    }).catch(() => void 0); // @todo How to process unhandled rejection here?\n\n    if (startTwilsock) {\n      this.services.twilsockClient.connect();\n    }\n  }\n\n  public static populateInitRegistrations(reg: InitRegistration) {\n    reg.populateInitRegistrations([NotificationTypes.TYPING_INDICATOR]);\n    SyncClient.populateInitRegistrations(reg);\n  }\n\n  /**\n   * Fired when a conversation becomes visible to the client. The event is also triggered when the client creates a new conversation.\n   * Fired for all conversations client has joined.\n   *\n   * Parameters:\n   * 1. {@link Conversation} `conversation` - the conversation in question\n   * @event\n   */\n  static readonly conversationAdded = \"conversationAdded\";\n\n  /**\n   * Fired when the client joins a conversation.\n   *\n   * Parameters:\n   * 1. {@link Conversation} `conversation` - the conversation in question\n   * @event\n   */\n  static readonly conversationJoined = \"conversationJoined\";\n\n  /**\n   * Fired when the client leaves a conversation.\n   *\n   * Parameters:\n   * 1. {@link Conversation} `conversation` - the conversation in question\n   * @event\n   */\n  static readonly conversationLeft = \"conversationLeft\";\n\n  /**\n   * Fired when a conversation is no longer visible to the client.\n   *\n   * Parameters:\n   * 1. {@link Conversation} `conversation` - the conversation in question\n   * @event\n   */\n  static readonly conversationRemoved = \"conversationRemoved\";\n\n  /**\n   * Fired when the attributes or the metadata of a conversation have been updated.\n   * During conversation's creation and initialization, this event might be fired multiple times\n   * for same joined or created conversation as new data is arriving from different sources.\n   *\n   * Parameters:\n   * 1. object `data` - info object provided with the event. It has the following properties:\n   *     * {@link Conversation} `conversation` - the conversation in question\n   *     * {@link ConversationUpdateReason}[] `updateReasons` - array of reasons for the update\n   * @event\n   */\n  static readonly conversationUpdated = \"conversationUpdated\";\n\n  /**\n   * Fired when a participant has joined a conversation.\n   *\n   * Parameters:\n   * 1. {@link Participant} `participant` - the participant in question\n   * @event\n   */\n  static readonly participantJoined = \"participantJoined\";\n\n  /**\n   * Fired when a participant has left a conversation.\n   *\n   * Parameters:\n   * 1. {@link Participant} `participant` - the participant in question\n   * @event\n   */\n  static readonly participantLeft = \"participantLeft\";\n\n  /**\n   * Fired when a participant's fields have been updated.\n   *\n   * Parameters:\n   * 1. object `data` - info object provided with the event. It has the following properties:\n   *     * {@link Participant} `participant` - the participant in question\n   *     * {@link ParticipantUpdateReason}[] `updateReasons` - array of reasons for the update\n   * @event\n   */\n  static readonly participantUpdated = \"participantUpdated\";\n\n  /**\n   * Fired when a new message has been added to the conversation on the server.\n   *\n   * Parameters:\n   * 1. {@link Message} `message` - the message in question\n   * @event\n   */\n  static readonly messageAdded = \"messageAdded\";\n\n  /**\n   * Fired when a message is removed from the message list of a conversation.\n   *\n   * Parameters:\n   * 1. {@link Message} `message` - the message in question\n   * @event\n   */\n  static readonly messageRemoved = \"messageRemoved\";\n\n  /**\n   * Fired when the fields of an existing message are updated with new values.\n   *\n   * Parameters:\n   * 1. object `data` - info object provided with the event. It has the following properties:\n   *     * {@link Message} `message` - the message in question\n   *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for the update\n   * @event\n   */\n  static readonly messageUpdated = \"messageUpdated\";\n\n  /**\n   * Fired when the token is about to expire and needs to be updated.\n   * * Parameters:\n   * 1. number `message` - token's time to live\n   * @event\n   */\n  static readonly tokenAboutToExpire = \"tokenAboutToExpire\";\n\n  /**\n   * Fired when the token has expired.\n   * @event\n   */\n  static readonly tokenExpired = \"tokenExpired\";\n\n  /**\n   * Fired when a participant has stopped typing.\n   *\n   * Parameters:\n   * 1. {@link Participant} `participant` - the participant in question\n   * @event\n   */\n  static readonly typingEnded = \"typingEnded\";\n\n  /**\n   * Fired when a participant has started typing.\n   *\n   * Parameters:\n   * 1. {@link Participant} `participant` - the participant in question\n   * @event\n   */\n  static readonly typingStarted = \"typingStarted\";\n\n  /**\n   * Fired when the client has received (and parsed) a push notification via one of the push channels (apn or fcm).\n   *\n   * Parameters:\n   * 1. {@link PushNotification} `pushNotification` - the push notification in question\n   * @event\n   */\n  static readonly pushNotification = \"pushNotification\";\n\n  /**\n   * Fired when the client has subscribed to a user.\n   *\n   * Parameters:\n   * 1. {@link User} `user` - the user in question\n   * @event\n   */\n  static readonly userSubscribed = \"userSubscribed\";\n\n  /**\n   * Fired when the client has unsubscribed from a user.\n   *\n   * Parameters:\n   * 1. {@link User} `user` - the user in question\n   * @event\n   */\n  static readonly userUnsubscribed = \"userUnsubscribed\";\n\n  /**\n   * Fired when the properties or the reachability status of a user have been updated.\n   *\n   * Parameters:\n   * 1. object `data` - info object provided with the event. It has the following properties:\n   *     * {@link User} `user` - the user in question\n   *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the update\n   * @event\n   */\n  static readonly userUpdated = \"userUpdated\";\n\n  /**\n   * Fired when the state of the client has been changed.\n   *\n   * Parameters:\n   * 1. {@link State} `state` - the new client state\n   * @event\n   */\n  static readonly stateChanged = \"stateChanged\";\n\n  /**\n   * Fired when the connection state of the client has been changed.\n   *\n   * Paremeters:\n   * 1. {@link ConnectionState} `state` - the new connection state\n   * @event\n   */\n  static readonly connectionStateChanged = \"connectionStateChanged\";\n\n  /**\n   * Fired when the connection is interrupted for an unexpected reason.\n   *\n   * Parameters:\n   * 1. object `data` - info object provided with the event. It has the following properties:\n   *     * boolean `terminal` - Twilsock will stop connection attempts if true\n   *     * string `message` - the error message of the root cause\n   *     * number? `httpStatusCode` - http status code if available\n   *     * number? `errorCode` - Twilio public error code if available\n   * @event\n   */\n  static readonly connectionError = \"connectionError\";\n\n  /**\n   * @deprecated Call constructor directly.\n   *\n   * Factory method to create a Conversations client instance.\n   *\n   * The factory method will automatically trigger connection.\n   * Do not use it if you need finer-grained control.\n   *\n   * Since this method returns an already-initialized client, some of the events\n   * will be lost because they happen *before* the initialization. It is\n   * recommended that `client.onWithReplay` is used as opposed to `client.on`\n   * for subscribing to client events. The `client.onWithReplay` will re-emit\n   * the most recent value for a given event if it emitted before the\n   * subscription.\n   *\n   * @param token Access token.\n   * @param options Options to customize the client.\n   * @returns Returns a fully initialized client.\n   */\n  @validateTypesAsync(\"string\", [\"undefined\", pureObject])\n  static async create(\n    token: string,\n    options?: ClientOptions | null\n  ): Promise<Client> {\n    // The logic is as follows:\n    // - If twilsock is not passed in, then the ConversationsClient constructor will call twilsock.connect() by itself\n    //   and we do not need to do it here.\n    // - If twilsock was passed in from the outside, but customer called ConversationsClient.create() then they are\n    //   using an obsolete workflow and the startup sequence will never complete.\n    if (options?.twilsockClient) {\n      throw new Error(\n        \"Obsolete usage of ConversationsClient.create() \" +\n          \"factory method: if you pass twilsock from the outside then you must \" +\n          \"use ConversationsClient constructor and be prepared to work with \" +\n          \"uninitialized client.\"\n      );\n    }\n\n    const client = new Client(token, options);\n    await client._ensureReady;\n\n    return client;\n  }\n\n  /**\n   * Information of the logged-in user. Before client initialization, returns an\n   * uninitialized user. Will trigger a {@link Client.userUpdated} event after\n   * initialization.\n   */\n  public get user(): User {\n    return this._myself;\n  }\n\n  /**\n   * Client reachability state. Throws if accessed before the client\n   * initialization was completed.\n   */\n  public get reachabilityEnabled(): boolean {\n    if (!this.configuration) {\n      throw new Error(\n        \"Reachability information could not yet be accessed as the client \" +\n          \"has not yet been initialized. Subscribe to the 'stateChanged' event \" +\n          \"to properly react to the client initialization.\"\n      );\n    }\n\n    return this.configuration.reachabilityEnabled;\n  }\n\n  public get token(): string {\n    return this.fpaToken;\n  }\n\n  private _subscribeToPushNotifications(channelType: NotificationsChannelType) {\n    [\n      NotificationTypes.NEW_MESSAGE,\n      NotificationTypes.ADDED_TO_CONVERSATION,\n      NotificationTypes.REMOVED_FROM_CONVERSATION,\n      NotificationTypes.TYPING_INDICATOR,\n      NotificationTypes.CONSUMPTION_UPDATE,\n    ].forEach((messageType) => {\n      this.services.notificationClient.subscribe(channelType, messageType);\n    });\n  }\n\n  private _unsubscribeFromPushNotifications(\n    channelType: NotificationsChannelType\n  ) {\n    [\n      NotificationTypes.NEW_MESSAGE,\n      NotificationTypes.ADDED_TO_CONVERSATION,\n      NotificationTypes.REMOVED_FROM_CONVERSATION,\n      NotificationTypes.TYPING_INDICATOR,\n      NotificationTypes.CONSUMPTION_UPDATE,\n    ].forEach((messageType) => {\n      this.services.notificationClient.unsubscribe(channelType, messageType);\n    });\n  }\n\n  private async _initialize() {\n    const configurationResponse =\n      await this.services.commandExecutor.fetchResource<\n        void,\n        ConfigurationResponse\n      >(\"Client/v2/Configuration\");\n\n    this.configuration = new Configuration(\n      this.options as ClientOptions,\n      configurationResponse,\n      log\n    );\n\n    this._myself._resolveInitialization(\n      this.configuration,\n      this.configuration.userIdentity,\n      this.configuration.userInfo,\n      true\n    );\n\n    this.services.typingIndicator = new TypingIndicator(\n      this.getConversationBySid.bind(this),\n      this.configuration,\n      this.services\n    );\n    this.services.network = new Network(this.configuration, this.services);\n\n    this.services.users = new Users(\n      this._myself,\n      this.configuration,\n      this.services\n    );\n    this.services.users.on(\"userSubscribed\", (user) => {\n      this.emit(\"userSubscribed\", user);\n    });\n    this.services.users.on(\"userUpdated\", (args: UserUpdatedEventArgs) =>\n      this.emit(\"userUpdated\", args)\n    );\n    this.services.users.on(\"userUnsubscribed\", (user) => {\n      this.emit(\"userUnsubscribed\", user);\n    });\n\n    this.conversations = new ConversationsEntity(\n      this.configuration,\n      this.services\n    );\n\n    this.conversations.on(\"conversationAdded\", (conversation) => {\n      this.emit(\"conversationAdded\", conversation);\n    });\n    this.conversations.on(\"conversationRemoved\", (conversation) => {\n      this.emit(\"conversationRemoved\", conversation);\n    });\n    this.conversations.on(\"conversationJoined\", (conversation) => {\n      this.emit(\"conversationJoined\", conversation);\n    });\n    this.conversations.on(\"conversationLeft\", (conversation) => {\n      this.emit(\"conversationLeft\", conversation);\n    });\n    this.conversations.on(\n      \"conversationUpdated\",\n      (args: ConversationUpdatedEventArgs) =>\n        this.emit(\"conversationUpdated\", args)\n    );\n\n    this.conversations.on(\"participantJoined\", (participant) => {\n      this.emit(\"participantJoined\", participant);\n    });\n    this.conversations.on(\"participantLeft\", (participant) => {\n      this.emit(\"participantLeft\", participant);\n    });\n    this.conversations.on(\n      \"participantUpdated\",\n      (args: ParticipantUpdatedEventArgs) =>\n        this.emit(\"participantUpdated\", args)\n    );\n\n    this.conversations.on(\"messageAdded\", (message) =>\n      this.emit(\"messageAdded\", message)\n    );\n    this.conversations.on(\"messageUpdated\", (args: MessageUpdatedEventArgs) =>\n      this.emit(\"messageUpdated\", args)\n    );\n    this.conversations.on(\"messageRemoved\", (message) =>\n      this.emit(\"messageRemoved\", message)\n    );\n\n    this.conversations.on(\"typingStarted\", (participant) =>\n      this.emit(\"typingStarted\", participant)\n    );\n    this.conversations.on(\"typingEnded\", (participant) =>\n      this.emit(\"typingEnded\", participant)\n    );\n\n    this.conversationsPromise = this.conversations\n      .fetchConversations()\n      .then(() => this.conversations)\n      .catch((error) => {\n        throw error;\n      });\n\n    await this.services.users.myself._ensureFetched();\n\n    Client.supportedPushChannels.forEach((channelType) =>\n      this._subscribeToPushNotifications(channelType)\n    );\n    this.services.typingIndicator.initialize();\n\n    this.services.mcsClient = new McsClient(\n      this.fpaToken,\n      this.configuration.links.mediaService,\n      this.configuration.links.mediaSetService,\n      {\n        ...this.options,\n        transport: undefined,\n      }\n    );\n\n    this._resolveEnsureReady();\n    this.emit(\"stateChanged\", \"initialized\");\n  }\n\n  /**\n   * Gracefully shut down the client.\n   */\n  async shutdown(): Promise<void> {\n    await this._ensureReady;\n    await this.services.twilsockClient.disconnect();\n  }\n\n  /**\n   * Update the token used by the client and re-register with the Conversations services.\n   * @param token New access token.\n   */\n  @validateTypesAsync(nonEmptyString)\n  async updateToken(token: string): Promise<Client> {\n    await this._ensureReady;\n    log.info(\"updateToken\");\n\n    if (this.fpaToken === token) {\n      return this;\n    }\n\n    await this.services.twilsockClient.updateToken(token);\n    await this.services.notificationClient.updateToken(token);\n    await this.services.mcsClient.updateToken(token);\n    this.fpaToken = token;\n\n    return this;\n  }\n\n  /**\n   * Get a known conversation by its SID.\n   * @param conversationSid Conversation sid\n   */\n  @validateTypesAsync(nonEmptyString)\n  async getConversationBySid(conversationSid: string): Promise<Conversation> {\n    await this._ensureReady;\n    await this.conversations.myConversationsRead.promise;\n    let conversation = await this.conversations.getConversation(\n      conversationSid\n    );\n\n    if (!conversation) {\n      conversation = await this.conversations.peekConversation(conversationSid);\n    }\n\n    if (!conversation) {\n      throw new Error(`Conversation with SID ${conversationSid} is not found.`);\n    }\n\n    return conversation;\n  }\n\n  /**\n   * Get a known conversation by its unique identifier name.\n   * @param uniqueName The unique identifier name of the conversation.\n   */\n  @validateTypesAsync(nonEmptyString)\n  async getConversationByUniqueName(uniqueName: string): Promise<Conversation> {\n    await this._ensureReady;\n    await this.conversations.myConversationsRead.promise;\n    const conversation = await this.conversations.getConversationByUniqueName(\n      uniqueName\n    );\n\n    if (!conversation) {\n      throw new Error(\n        `Conversation with unique name ${uniqueName} is not found.`\n      );\n    }\n\n    return conversation;\n  }\n\n  /**\n   * Get the current list of all the subscribed conversations.\n   */\n  public async getSubscribedConversations(): Promise<Paginator<Conversation>> {\n    await this._ensureReady;\n    return this.conversationsPromise.then((conversations) =>\n      conversations.getConversations()\n    );\n  }\n\n  /**\n   * Create a conversation on the server and subscribe to its events.\n   * The default is a conversation with an empty friendly name.\n   * @param options Options for the conversation.\n   */\n  @validateTypesAsync([\n    \"undefined\",\n    objectSchema(\"conversation options\", {\n      friendlyName: [\"string\", \"undefined\"],\n      isPrivate: [\"boolean\", \"undefined\"],\n      uniqueName: [\"string\", \"undefined\"],\n    }),\n  ])\n  public async createConversation(\n    options?: CreateConversationOptions\n  ): Promise<Conversation> {\n    await this._ensureReady;\n    options = options || {};\n    return this.conversationsPromise.then((conversationsEntity) =>\n      conversationsEntity.addConversation(options)\n    );\n  }\n\n  /**\n   * Register for push notifications.\n   * @param channelType Channel type.\n   * @param registrationId Push notification ID provided by the FCM/APNS service on the platform.\n   */\n  @validateTypesAsync(literal(\"fcm\", \"apn\"), \"string\")\n  public async setPushRegistrationId(\n    channelType: NotificationsChannelType,\n    registrationId: string\n  ): Promise<void> {\n    await this._ensureReady;\n    this._subscribeToPushNotifications(channelType);\n    this.services.notificationClient.setPushRegistrationId(\n      channelType,\n      registrationId\n    );\n    await this.services.notificationClient.commitChanges(); // Committing before this point is useless because we have no push id\n  }\n\n  /**\n   * Unregister from push notifications.\n   * @param channelType Channel type.\n   * @deprecated Use removePushRegistrations() instead.\n   */\n  @validateTypesAsync(literal(\"fcm\", \"apn\"))\n  public async unsetPushRegistrationId(\n    channelType: NotificationsChannelType\n  ): Promise<void> {\n    await this._ensureReady;\n    this._unsubscribeFromPushNotifications(channelType);\n    await this.services.notificationClient.commitChanges();\n  }\n\n  /**\n   * Clear existing registrations directly using provided device token.\n   * This is useful to ensure stopped subscriptions without resubscribing.\n   *\n   * This function goes completely beside the state machine and removes all registrations.\n   * Use with caution: if it races with current state machine operations, madness will ensue.\n   *\n   * @param channelType Channel type.\n   * @param registrationId Push notification ID provided by the FCM/APNS service on the platform.\n   */\n  @validateTypesAsync(literal(\"fcm\", \"apn\"), nonEmptyString)\n  public async removePushRegistrations(\n    channelType: ChannelType,\n    registrationId: string\n  ): Promise<void> {\n    // do not await this._ensureReady() here - it could be called at any moment\n    await this.services.notificationClient.removeRegistrations(\n      channelType,\n      registrationId\n    );\n  }\n\n  private static parsePushNotificationChatData(\n    data: Record<string, unknown>\n  ): Record<string, unknown> {\n    const result: Record<string, unknown> = {};\n\n    for (const key in Client.supportedPushDataFields) {\n      if (typeof data[key] === \"undefined\" || data[key] === null) {\n        continue;\n      }\n\n      if (key !== \"message_index\") {\n        result[Client.supportedPushDataFields[key]] = data[key];\n        continue;\n      }\n\n      if (parseToNumber(data[key]) !== null) {\n        result[Client.supportedPushDataFields[key]] = Number(data[key]);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Static method for push notification payload parsing. Returns parsed push as a {@link PushNotification} object.\n   * @param notificationPayload Push notification payload.\n   */\n  @validateTypes(pureObject)\n  static parsePushNotification(notificationPayload): PushNotification {\n    log.debug(\n      \"parsePushNotification, notificationPayload=\",\n      notificationPayload\n    );\n\n    // APNS specifics\n    if (typeof notificationPayload.aps !== \"undefined\") {\n      if (!notificationPayload.twi_message_type) {\n        throw new Error(\n          \"Provided push notification payload does not contain Programmable Chat push notification type\"\n        );\n      }\n\n      const data = Client.parsePushNotificationChatData(notificationPayload);\n\n      const apsPayload = notificationPayload.aps;\n      let body: string | null;\n      let title: string | null = null;\n      if (typeof apsPayload.alert === \"string\") {\n        body = apsPayload.alert || null;\n      } else {\n        body = apsPayload.alert.body || null;\n        title = apsPayload.alert.title || null;\n      }\n\n      return new PushNotification({\n        title,\n        body,\n        sound: apsPayload.sound || null,\n        badge: apsPayload.badge || null,\n        action: apsPayload.category || null,\n        type: notificationPayload.twi_message_type,\n        data: data,\n      });\n    }\n\n    // FCM specifics\n    if (typeof notificationPayload.data !== \"undefined\") {\n      const dataPayload = notificationPayload.data;\n      if (!dataPayload.twi_message_type) {\n        throw new Error(\n          \"Provided push notification payload does not contain Programmable Chat push notification type\"\n        );\n      }\n\n      const data = Client.parsePushNotificationChatData(\n        notificationPayload.data\n      );\n      return new PushNotification({\n        title: dataPayload.twi_title || null,\n        body: dataPayload.twi_body || null,\n        sound: dataPayload.twi_sound || null,\n        badge: null,\n        action: dataPayload.twi_action || null,\n        type: dataPayload.twi_message_type,\n        data: data,\n      });\n    }\n\n    throw new Error(\n      \"Provided push notification payload is not Programmable Chat notification\"\n    );\n  }\n\n  public parsePushNotification = Client.parsePushNotification;\n\n  /**\n   * Handle push notification payload parsing and emit the {@link Client.pushNotification} event on this {@link Client} instance.\n   * @param notificationPayload Push notification payload\n   */\n  @validateTypesAsync(pureObject)\n  async handlePushNotification(notificationPayload): Promise<void> {\n    await this._ensureReady;\n    log.debug(\n      \"handlePushNotification, notificationPayload=\",\n      notificationPayload\n    );\n    this.emit(\n      \"pushNotification\",\n      Client.parsePushNotification(notificationPayload)\n    );\n  }\n\n  /**\n   * Gets a user with the given identity. If it's in the subscribed list, then return the user object from it;\n   * if not, then subscribe and add user to the subscribed list.\n   * @param identity Identity of the user.\n   * @returns A fully initialized user.\n   */\n  @validateTypesAsync(nonEmptyString)\n  public async getUser(identity: string): Promise<User> {\n    await this._ensureReady;\n    return this.services.users.getUser(identity);\n  }\n\n  /**\n   * Get a list of subscribed user objects.\n   */\n  public async getSubscribedUsers(): Promise<Array<User>> {\n    await this._ensureReady;\n    return this.services.users.getSubscribedUsers();\n  }\n}\n\nexport {\n  Client,\n  State,\n  ConnectionState,\n  NotificationsChannelType,\n  LogLevel,\n  ClientOptions,\n  CreateConversationOptions,\n};\n"],"names":["Logger","version","Client","ReplayEventEmitter","deepClone","User","InitRegistration","TwilsockClient","NotificationClient","SyncClient","CommandExecutor","TelemetryEventDescription","TelemetryPoint","NotificationTypes","Configuration","TypingIndicator","Network","Users","ConversationsEntity","McsClient","parseToNumber","PushNotification","__decorate","validateTypesAsync","nonEmptyString","objectSchema","literal","pureObject","validateTypes","validateConstructorTypes"],"mappings":"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"}